{"version":3,"file":"component---src-pages-index-tsx-567443e0cf0f796b1417.js","mappings":";2MAcA,IAAIA,EAAE,WAAW,OAAOA,EAAEC,OAAOC,QAAQ,SAASF,GAAG,IAAI,IAAIG,EAAEC,EAAE,EAAEC,EAAEC,UAAUC,OAAOH,EAAEC,EAAED,IAAI,IAAI,IAAII,KAAKL,EAAEG,UAAUF,GAAGH,OAAOQ,UAAUC,eAAeC,KAAKR,EAAEK,KAAKR,EAAEQ,GAAGL,EAAEK,IAAI,OAAOR,CAAC,EAAEA,EAAEY,MAAMC,KAAKP,UAAU,EAAMH,EAAE,6DAA6iB,MAAM,MAAMH,EAAEc,MAAM,KAAKC,MAAM,GAAG,IAAI,IAAIX,EAAE,EAAEA,EAAED,KAAWC,EAAEJ,EAAEG,EAAEa,WAAWZ,IAAIA,CAAE,EAAlF,GAAsF,IAAYI,EAAES,EAAEC,EAAZb,EAApkBL,IAAI,IAAIA,GAAG,iBAAiBA,EAAE,MAAM,IAAImB,MAAM,mCAAmCnB,MAAM,GAAGA,EAAEoB,MAAM,aAAa,MAAM,IAAID,MAAM,6BAA6BnB,EAAEoB,MAAM,iBAAiB,MAAMhB,EAAEJ,EAAEoB,MAAM,UAAUf,EAAED,EAAEA,EAAE,GAAGG,OAAO,EAAEC,GAAGR,EAAEO,OAAOF,IAAIgB,KAAKC,IAAI,IAAID,KAAKC,IAAI,MAAM,IAAI,EAAE,OAAO,IAAIC,WAAW,IAAI,IAAIA,WAAWlB,MAAML,EAAEoB,MAAM,WAAWI,KAAKxB,GAAGG,EAAEsB,QAAQzB,KAAK0B,QAAO,CAAE1B,EAAEG,IAAMH,EAAEwB,KAAKxB,IAAI,MAAMI,EAAE,GAAGJ,EAAEG,EAAE,OAAOA,EAAEC,GAAG,EAAEA,CAAE,KAAI,IAAImB,WAAWf,IAAImB,UAAUC,QAAQX,GAAE,EAAGjB,GAAGiB,EAAEA,GAAGjB,MAAM,IAAIiB,GAA2GY,GAAGrB,EAAE,SAASR,EAAEG,GAAGF,OAAO6B,eAAe3B,EAAE,aAAa,CAAC4B,OAAM,IAAK5B,EAAE6B,QAAQ7B,EAAE8B,YAAO,EAAO,MAAM7B,EAAE,mCAAmCC,EAAE,CAAC,EAAE,IAAI,IAAIL,EAAE,EAAEA,EAAE,GAAGA,IAAI,CAAC,MAAMG,EAAEC,EAAE8B,OAAOlC,GAAGK,EAAEF,GAAGH,CAAC,CAAC,SAASQ,EAAER,GAAG,MAAMG,EAAEH,GAAG,GAAG,OAAO,SAASA,IAAI,EAAE,YAAYG,GAAG,EAAE,GAAG,YAAYA,GAAG,EAAE,GAAG,YAAYA,GAAG,EAAE,GAAG,aAAaA,GAAG,EAAE,GAAG,YAAYA,GAAG,EAAE,EAAE,CAAC,SAASc,EAAEjB,GAAG,IAAIG,EAAE,EAAE,IAAI,IAAIC,EAAE,EAAEA,EAAEJ,EAAEO,SAASH,EAAE,CAAC,MAAMC,EAAEL,EAAEgB,WAAWZ,GAAG,GAAGC,EAAE,IAAIA,EAAE,IAAI,MAAM,mBAAmBL,EAAE,IAAIG,EAAEK,EAAEL,GAAGE,GAAG,CAAC,CAACF,EAAEK,EAAEL,GAAG,IAAI,IAAIC,EAAE,EAAEA,EAAEJ,EAAEO,SAASH,EAAE,CAAC,MAAMC,EAAEL,EAAEgB,WAAWZ,GAAGD,EAAEK,EAAEL,GAAG,GAAGE,CAAC,CAAC,OAAOF,CAAC,CAAC,SAASe,EAAElB,EAAEG,EAAEC,EAAEC,GAAG,IAAIG,EAAE,EAAES,EAAE,EAAE,MAAMC,GAAG,GAAGd,GAAG,EAAEyB,EAAE,GAAG,IAAI,IAAIxB,EAAE,EAAEA,EAAEL,EAAEO,SAASF,EAAE,IAAIG,EAAEA,GAAGL,EAAEH,EAAEK,GAAGY,GAAGd,EAAEc,GAAGb,GAAGa,GAAGb,EAAEyB,EAAEM,KAAK3B,GAAGS,EAAEC,GAAG,GAAGb,EAAEY,EAAE,GAAGY,EAAEM,KAAK3B,GAAGJ,EAAEa,EAAEC,OAAO,CAAC,GAAGD,GAAGd,EAAE,MAAM,iBAAiB,GAAGK,GAAGJ,EAAEa,EAAEC,EAAE,MAAM,kBAAkB,CAAC,OAAOW,CAAC,CAAC,SAASA,EAAE7B,GAAG,OAAOkB,EAAElB,EAAE,EAAE,GAAE,EAAG,CAAC,SAASoC,EAAEpC,GAAG,MAAMG,EAAEe,EAAElB,EAAE,EAAE,GAAE,GAAI,GAAGc,MAAMuB,QAAQlC,GAAG,OAAOA,CAAC,CAAC,SAASmC,EAAEtC,GAAG,MAAMG,EAAEe,EAAElB,EAAE,EAAE,GAAE,GAAI,GAAGc,MAAMuB,QAAQlC,GAAG,OAAOA,EAAE,MAAM,IAAIgB,MAAMhB,EAAE,CAAC,SAASoC,EAAEvC,GAAG,IAAIG,EAAE,SAASe,EAAElB,EAAEI,GAAG,GAAGA,EAAEA,GAAG,GAAGJ,EAAEO,OAAO,EAAE,OAAOP,EAAE,aAAa,GAAGA,EAAEO,OAAOH,EAAE,MAAM,uBAAuB,MAAMc,EAAElB,EAAEwC,cAAcX,EAAE7B,EAAEyC,cAAc,GAAGzC,IAAIkB,GAAGlB,IAAI6B,EAAE,MAAM,qBAAqB7B,EAAE,MAAMoC,GAAGpC,EAAEkB,GAAGwB,YAAY,KAAK,IAAI,IAAIN,EAAE,MAAM,8BAA8BpC,EAAE,GAAG,IAAIoC,EAAE,MAAM,sBAAsBpC,EAAE,MAAMsC,EAAEtC,EAAE2C,MAAM,EAAEP,GAAGG,EAAEvC,EAAE2C,MAAMP,EAAE,GAAG,GAAGG,EAAEhC,OAAO,EAAE,MAAM,iBAAiB,IAAIqC,EAAE3B,EAAEqB,GAAG,GAAG,iBAAiBM,EAAE,OAAOA,EAAE,MAAMC,EAAE,GAAG,IAAI,IAAI7C,EAAE,EAAEA,EAAEuC,EAAEhC,SAASP,EAAE,CAAC,MAAMG,EAAEoC,EAAEL,OAAOlC,GAAGI,EAAEC,EAAEF,GAAG,QAAG,IAASC,EAAE,MAAM,qBAAqBD,EAAEyC,EAAEpC,EAAEoC,GAAGxC,EAAEJ,EAAE,GAAGuC,EAAEhC,QAAQsC,EAAEV,KAAK/B,EAAE,CAAC,OAAOwC,IAAIzC,EAAE,wBAAwBH,EAAE,CAAC8C,OAAOR,EAAES,MAAMF,EAAE,CAAC,OAAO1C,EAAE,WAAWH,EAAE,EAAE,UAAU,CAACgD,aAAa,SAAShD,EAAEG,GAAG,MAAMC,EAAEc,EAAElB,EAAEG,GAAG,GAAG,iBAAiBC,EAAE,OAAOA,CAAC,EAAE6C,OAAO,SAASjD,EAAEG,GAAG,MAAMC,EAAEc,EAAElB,EAAEG,GAAG,GAAG,iBAAiBC,EAAE,OAAOA,EAAE,MAAM,IAAIe,MAAMf,EAAE,EAAE8C,OAAO,SAASlD,EAAEK,EAAEa,GAAG,GAAGA,EAAEA,GAAG,GAAGlB,EAAEO,OAAO,EAAEF,EAAEE,OAAOW,EAAE,MAAM,IAAIiC,UAAU,wBAAwB,IAAItB,EAAEZ,EAAEjB,EAAEA,EAAEwC,eAAe,GAAG,iBAAiBX,EAAE,MAAM,IAAIV,MAAMU,GAAG,IAAIO,EAAEpC,EAAE,IAAI,IAAI,IAAIA,EAAE,EAAEA,EAAEK,EAAEE,SAASP,EAAE,CAAC,MAAMG,EAAEE,EAAEL,GAAG,GAAGG,GAAG,GAAG,EAAE,MAAM,IAAIgB,MAAM,kBAAkBU,EAAErB,EAAEqB,GAAG1B,EAAEiC,GAAGhC,EAAE8B,OAAO/B,EAAE,CAAC,IAAI,IAAIH,EAAE,EAAEA,EAAE,IAAIA,EAAE6B,EAAErB,EAAEqB,GAAGA,GAAG1B,EAAE,IAAI,IAAIH,EAAE,EAAEA,EAAE,IAAIA,EAAEoC,GAAGhC,EAAE8B,OAAOL,GAAG,GAAG,EAAE7B,GAAG,IAAI,OAAOoC,CAAC,EAAEgB,QAAQvB,EAAEwB,gBAAgBjB,EAAEkB,UAAUhB,EAAE,CAACnC,EAAE8B,OAAOM,EAAE,UAAUpC,EAAE6B,QAAQO,EAAE,UAAU,EAAE/B,EAAES,EAAE,CAACsC,QAAQ,CAAC,GAAGtC,EAAEsC,SAAStC,EAAEsC,UAAUrC,EAAEW,IAAIX,EAAEsC,YAAYvD,OAAOQ,UAAUC,eAAeC,KAAKO,EAAE,YAAYA,EAAEuC,QAAQ,IAAIrB,EAAEP,EAAEG,QAAQM,EAAET,EAAEI,OAAO,MAAMM,EAAE,CAAC,WAAW,YAAY,YAAY,UAAU,UAAU,YAAY,YAAY,YAAY,UAAU,UAAU,UAAU,WAAW,YAAY,YAAY,YAAY,YAAY,WAAW,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,YAAY,YAAY,YAAY,YAAY,YAAY,WAAW,UAAU,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,WAAW,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,WAAW,WAAW,WAAW,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,WAAW,WAAW,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,WAAwB,MAAMM,EAAE,WAAAa,GAAc7C,KAAK8C,EAAE,WAAW9C,KAAK+C,GAAG,WAAW/C,KAAKgD,EAAE,WAAWhD,KAAKiD,GAAG,WAAWjD,KAAKkD,EAAE,WAAWlD,KAAKmD,GAAG,WAAWnD,KAAKoD,EAAE,UAAUpD,KAAKqD,EAAE,WAAWrD,KAAKsD,MAAM,EAAEtD,KAAKuD,IAAI,IAAIC,GAAGC,GAAG,OAAOD,EAAE,IAAIE,YAAY,KAAKD,EAAE,GAAGzD,KAAK2D,MAAM,IAAIjD,WAAW8C,EAAEC,EAAE,IAAIzD,KAAK4D,MAAM,IAAIC,WAAWL,EAAEC,EAAE,IAAIA,GAAG,EAAE,CAAC,MAAAK,CAAO3E,GAAG,GAAG,iBAAiBA,EAAE,OAAOa,KAAK+D,MAAM5E,GAAG,GAAG,MAAMA,EAAE,MAAM,IAAImD,UAAU,wBAAwBnD,GAAG,MAAMG,EAAEH,EAAE6E,WAAWzE,EAAEJ,EAAE8E,WAAW,IAAIzE,EAAED,EAAE,GAAG,EAAEI,EAAE,EAAE,GAAGH,KAAK,EAAEF,MAAMU,KAAKsD,MAAM,IAAI,CAAC,MAAM/D,EAAE,IAAIsE,WAAW1E,EAAE+E,OAAO5E,EAAE,GAAGE,GAAG,KAAKA,KAAKQ,KAAKmE,OAAO5E,EAAEI,GAAG,GAAGA,GAAG,GAAGK,KAAKsD,OAAO3D,CAAC,CAAC,GAAG,IAAIR,EAAEiF,mBAAmBjF,EAAE+E,OAAO,CAAC,MAAM1E,EAAE,IAAIkB,WAAWvB,EAAE+E,OAAO5E,EAAEK,EAAEJ,EAAEI,GAAG,OAAOK,KAAKqE,OAAO7E,EAAE,CAAC,OAAOG,IAAIJ,EAAES,KAAKA,KAAKqE,OAAOlF,EAAEQ,EAAE,CAAC,MAAA0E,CAAOlF,EAAEG,GAAG,MAAMqE,MAAMpE,EAAEqE,MAAMpE,GAAGQ,KAAKL,EAAER,EAAEO,OAAO,IAAIJ,GAAG,EAAEA,EAAEK,GAAG,CAAC,MAAMS,EAAEJ,KAAKsD,MAAM,GAAG,IAAIjD,EAAED,EAAE,KAAKd,EAAEK,GAAGU,EAAE,IAAId,EAAEc,KAAKlB,EAAEG,KAAKe,GAAG,IAAIL,KAAKmE,OAAO3E,GAAGQ,KAAKsD,OAAOjD,EAAED,CAAC,CAAC,OAAOJ,IAAI,CAAC,KAAA+D,CAAM5E,GAAG,MAAMwE,MAAMrE,EAAEsE,MAAMrE,GAAGS,KAAKR,EAAEL,EAAEO,OAAO,IAAIC,EAAEK,KAAKuD,IAAI,IAAI,IAAInD,EAAE,EAAEA,EAAEZ,GAAG,CAAC,MAAMa,EAAEL,KAAKsD,MAAM,GAAG,IAAItC,EAAEX,EAAE,KAAKD,EAAEZ,GAAGwB,EAAE,IAAI,CAAC,IAAIzB,EAAE,EAAEJ,EAAEgB,WAAWC,KAAKb,EAAE,IAAID,EAAE0B,KAAKzB,EAAEA,EAAE,MAAMD,EAAE0B,KAAK,IAAIzB,IAAI,EAAED,EAAE0B,KAAK,IAAI,GAAGzB,GAAGA,EAAE,OAAOA,EAAE,OAAOD,EAAE0B,KAAK,IAAIzB,IAAI,GAAGD,EAAE0B,KAAK,IAAIzB,IAAI,EAAE,GAAGD,EAAE0B,KAAK,IAAI,GAAGzB,GAAGI,GAAGJ,IAAI,KAAKI,IAAI,KAAK,KAAKJ,GAAG,MAAMD,EAAE0B,KAAK,IAAIzB,IAAI,GAAGD,EAAE0B,KAAK,IAAIzB,IAAI,GAAG,GAAGD,EAAE0B,KAAK,IAAIzB,IAAI,EAAE,GAAGD,EAAE0B,KAAK,IAAI,GAAGzB,EAAEI,EAAE,GAAGA,EAAEJ,CAAC,CAACyB,GAAG,KAAKhB,KAAKmE,OAAO5E,GAAGA,EAAE,GAAGA,EAAE,KAAKS,KAAKsD,OAAOtC,EAAEX,CAAC,CAAC,OAAOL,KAAKuD,IAAI5D,EAAEK,IAAI,CAAC,MAAAmE,CAAOhF,EAAEG,GAAG,IAAIwD,EAAEvD,EAAEwD,EAAEvD,EAAEwD,EAAErD,EAAEsD,EAAE7C,EAAE8C,EAAE7C,EAAE8C,EAAEnC,EAAEoC,EAAE7B,EAAE8B,EAAE5B,GAAGzB,KAAK+B,EAAE,EAAE,IAAIzC,GAAG,EAAEyC,EAAE,IAAIuC,EAAEvC,KAAKwC,EAAEpF,EAAEG,MAAM,IAAIyC,EAAE,GAAGA,EAAE,GAAGA,IAAIuC,EAAEvC,GAAGe,EAAEwB,EAAEvC,EAAE,IAAIuC,EAAEvC,EAAE,GAAGyC,EAAEF,EAAEvC,EAAE,KAAKuC,EAAEvC,EAAE,IAAI,EAAE,IAAIA,EAAE,EAAEA,EAAE,GAAGA,IAAI,CAAC,MAAM5C,EAAEsC,EAAEyB,EAAE7C,GAAGoE,EAAEpE,EAAEW,EAAEO,GAAGG,EAAEK,GAAGuC,EAAEvC,GAAG,EAAEzC,EAAEoF,EAAEnF,GAAGoF,EAAEpF,EAAEC,EAAEG,GAAG,EAAE8B,EAAEF,EAAEA,EAAEP,EAAEA,EAAEX,EAAEA,EAAED,EAAEjB,EAAE,EAAEiB,EAAET,EAAEA,EAAEH,EAAEA,EAAED,EAAEA,EAAEJ,EAAEG,EAAE,CAAC,CAACU,KAAK8C,EAAEvD,EAAES,KAAK8C,EAAE,EAAE9C,KAAK+C,EAAEvD,EAAEQ,KAAK+C,EAAE,EAAE/C,KAAKgD,EAAErD,EAAEK,KAAKgD,EAAE,EAAEhD,KAAKiD,EAAE7C,EAAEJ,KAAKiD,EAAE,EAAEjD,KAAKkD,EAAE7C,EAAEL,KAAKkD,EAAE,EAAElD,KAAKmD,EAAEnC,EAAEhB,KAAKmD,EAAE,EAAEnD,KAAKoD,EAAE7B,EAAEvB,KAAKoD,EAAE,EAAEpD,KAAKqD,EAAE5B,EAAEzB,KAAKqD,EAAE,CAAC,CAAC,MAAAuB,CAAOzF,GAAG,MAAMwE,MAAMrE,EAAEsE,MAAMrE,GAAGS,KAAK,IAAIR,EAAEQ,KAAKsD,MAAM,GAAG,EAAE,IAAIhE,EAAEE,KAAK,IAAI,EAAEA,GAAGF,EAAEE,KAAK,EAAE,GAAGA,IAAI,EAAEA,EAAE,GAAG,CAAC,KAAKA,EAAE,IAAID,EAAEC,KAAK,EAAEA,EAAE,EAAEQ,KAAKmE,OAAO5E,EAAE,CAAC,KAAKC,EAAE,IAAID,EAAEC,KAAK,EAAE,MAAMG,EAAE,EAAEK,KAAKsD,MAAMlD,GAAG,WAAWT,KAAK,EAAEU,GAAGV,EAAES,GAAG,WAAW,OAAOC,IAAId,EAAE,IAAIgF,EAAElE,IAAID,IAAIb,EAAE,IAAIgF,EAAEnE,IAAIJ,KAAKmE,OAAO5E,GAAG,QAAQJ,EAAEa,KAAK6E,OAAO7E,KAAK8E,MAAM,CAAC,IAAAD,GAAO,MAAM/B,EAAE3D,EAAE4D,EAAEzD,EAAE0D,EAAEzD,EAAE0D,EAAEzD,EAAE0D,EAAEvD,EAAEwD,EAAE/C,EAAEgD,EAAE/C,EAAEgD,EAAErC,GAAGhB,KAAK,OAAO+E,EAAE5F,GAAG4F,EAAEzF,GAAGyF,EAAExF,GAAGwF,EAAEvF,GAAGuF,EAAEpF,GAAGoF,EAAE3E,GAAG2E,EAAE1E,GAAG0E,EAAE/D,EAAE,CAAC,IAAA8D,GAAO,MAAMhC,EAAE3D,EAAE4D,EAAEzD,EAAE0D,EAAEzD,EAAE0D,EAAEzD,EAAE0D,EAAEvD,EAAEwD,EAAE/C,EAAEgD,EAAE/C,EAAEgD,EAAErC,EAAE2C,MAAMpC,EAAEqC,MAAMnC,GAAGzB,KAAK,OAAOyB,EAAE,GAAG8C,EAAEpF,GAAGsC,EAAE,GAAG8C,EAAEjF,GAAGmC,EAAE,GAAG8C,EAAEhF,GAAGkC,EAAE,GAAG8C,EAAE/E,GAAGiC,EAAE,GAAG8C,EAAE5E,GAAG8B,EAAE,GAAG8C,EAAEnE,GAAGqB,EAAE,GAAG8C,EAAElE,GAAGoB,EAAE,GAAG8C,EAAEvD,GAAGO,EAAEO,MAAM,EAAE,GAAG,EAAE,MAAMwC,EAAE,IAAIT,WAAW,IAAI,IAAIL,EAAEC,EAAE,EAAE,MAAMsB,EAAE5F,IAAIA,EAAE,YAAY6F,SAAS,IAAIC,QAAQ,GAAGV,EAAE,MAAM,IAAI7D,WAAW,IAAIwE,YAAY,CAAC,QAAQhB,QAAQ,GAAG/E,GAAGA,EAAEA,GAAGA,GAAG,GAAG,WAAWA,GAAG,EAAE,SAASA,GAAG,EAAE,MAAMA,GAAG,GAAG,IAAIsF,EAAE,CAACtF,EAAEG,EAAEC,IAAIA,EAAEJ,GAAGG,EAAEC,GAAGoF,EAAE,CAACxF,EAAEG,EAAEC,IAAIJ,EAAEG,EAAEC,GAAGJ,EAAEG,GAAGoF,EAAEvF,IAAIA,IAAI,EAAEA,GAAG,KAAKA,IAAI,GAAGA,GAAG,KAAKA,IAAI,GAAGA,GAAG,IAAI+D,EAAE/D,IAAIA,IAAI,EAAEA,GAAG,KAAKA,IAAI,GAAGA,GAAG,KAAKA,IAAI,GAAGA,GAAG,GAAGqF,EAAErF,IAAIA,IAAI,EAAEA,GAAG,KAAKA,IAAI,GAAGA,GAAG,IAAIA,IAAI,EAAE2D,EAAE3D,IAAIA,IAAI,GAAGA,GAAG,KAAKA,IAAI,GAAGA,GAAG,IAAIA,IAAI,GAAG,IAAIgG,EAAEC,EAAEC,EAAE,SAASlG,GAAG,OAA0G,IAAI6C,GAAK8B,OAAO3E,GAAGyF,QAAQ,GAAG,SAASzF,GAAGA,EAAEmG,QAAQ,UAAUnG,EAAEoG,QAAQ,UAAUpG,EAAEqG,QAAQ,SAAS,CAAvE,CAAyEL,IAAIA,EAAE,CAAC,IAAI,SAAShG,GAAGA,EAAEsG,MAAM,QAAQtG,EAAEuG,KAAK,OAAOvG,EAAEwG,OAAO,SAASxG,EAAEyG,MAAM,QAAQzG,EAAE0G,KAAK,MAAM,CAAzF,CAA2FT,IAAIA,EAAE,CAAC,IAAI,IAAIpC,EAAE,CAAC,EAAE,CAAC8C,KAAKV,EAAEK,MAAMM,QAAQZ,EAAEG,SAAS,IAAI,CAACQ,KAAKV,EAAEK,MAAMM,QAAQZ,EAAEI,SAAS,EAAE,CAACO,KAAKV,EAAEM,KAAKK,QAAQZ,EAAEG,SAAS,IAAI,CAACQ,KAAKV,EAAEM,KAAKK,QAAQZ,EAAEI,UAAUS,EAAE,SAAS1G,GAAG,IAAIC,EAAEI,EAAEL,EAAE2F,OAAO,EAAE,GAAGtD,cAAc,GAAG,OAAOhC,GAAG,OAAOA,EAAE,OAAO,SAASR,GAAG,IAAIG,EAAE,IAAIA,EAAEH,EAAE8G,WAAW,SAAS9G,EAAE8G,WAAW,SAAS9G,EAAE8G,WAAW,UAAU1E,EAAEa,OAAOjD,GAAGsC,EAAEW,OAAOjD,EAAE,CAAC,MAAMA,GAAG,MAAM,IAAImB,MAAM,kBAAkB,CAAC,IAAIf,EAAE,CAAC2G,GAAGf,EAAEG,QAAQa,GAAGhB,EAAEI,QAAQa,KAAKjB,EAAEK,SAASlG,EAAE2C,QAAQ,QAAG,IAAS1C,EAAE,MAAM,IAAIe,MAAM,mBAAmB,IAAId,EAAEF,EAAE4C,MAAM,GAAG,GAAG1C,EAAE,GAAGA,EAAE,GAAG,MAAM,IAAIc,MAAM,mBAAmB,MAAM,CAACc,QAAO,EAAG2E,QAAQxG,EAAE8G,QAAQlH,EAAE2G,KAAK,KAAKrE,EAAEgB,UAAUnD,EAAE4C,MAAMJ,MAAM,IAAIpC,OAAO0F,EAAEO,OAAO,IAAInG,EAAE4F,EAAES,KAAKT,EAAEQ,MAAM,CAA9b,CAAgctG,GAAG,IAAIC,EAAEC,EAAEF,EAAE,CAAC,MAAMH,GAAG,MAAM,IAAImB,MAAM,kBAAkB,CAAC,IAAIF,EAAEb,EAAEG,OAAO,GAAG,KAAKU,EAAE,MAAM,IAAIE,MAAM,mBAAmB,IAAID,EAAEd,EAAE,GAAGyB,EAAEzB,EAAEuC,MAAM1B,EAAE,EAAEA,GAAGsB,EAAEnC,EAAEuC,MAAM,EAAE1B,EAAE,GAAG2B,EAAEsD,EAAEA,EAAE3D,IAAII,MAAM,EAAE,GAAG,GAAGd,EAAEsF,MAAK,SAAUnH,EAAEG,GAAG,OAAOH,IAAI4C,EAAEzC,EAAG,IAAG,MAAM,IAAIgB,MAAM,mBAAmB,IAAIlB,OAAOmH,KAAKvD,GAAGrC,IAAI6F,QAAQC,SAASpG,GAAG,MAAM,IAAIC,MAAM,mBAAmB,OAAOnB,EAAEA,EAAE,CAAC,EAAE6D,EAAE3C,IAAI,CAACgG,QAAQ/G,EAAE8B,QAAO,GAAI,ECHpiQ,MAAMsF,UAAoBpE,UAC7B,WAAAO,CAAY8D,EAASC,GACjB,IAAIC,EACJ,MAAM,QAAEC,EAAO,YAAEC,KAAgBC,GAASL,GACpC,KAAEM,GAASN,EACXO,EAAwB,IAAhBD,EAAKvH,OAAeoH,EAAU,YAAYG,EAAKE,KAAK,WAAWL,IAC7EM,MAAML,GAAeG,GACjBH,UACA/G,KAAKkH,MAAQA,GAEjB9H,OAAOC,OAAOW,KAAMgH,GACpBhH,KAAKqH,KAAOrH,KAAK6C,YAAYwE,KAC7BrH,KAAK4G,SAAW,IACJC,IAAWA,EAAS,CAACF,KAAYC,KAEjD,ECXG,SAASU,EAASpG,GACrB,MAAwB,iBAAVA,GAAgC,OAAVA,CACxC,CAoBO,SAAS,EAAMA,GAClB,MAAqB,iBAAVA,EACAA,EAAM8D,WAGO,iBAAV9D,EAAqBqG,KAAKC,UAAUtG,GAAS,GAAGA,GAClE,CAuBO,SAASuG,EAAUC,EAAQC,EAASC,EAAQ1G,GAC/C,IAAe,IAAXwG,EACA,QAEgB,IAAXA,EAELA,EAAS,CAAC,EAEa,iBAAXA,IAEZA,EAAS,CAAEZ,QAASY,IAExB,MAAM,KAAET,EAAI,OAAEY,GAAWF,GACnB,KAAE7B,GAAS8B,GACX,WAAEE,EAAU,QAAEhB,EAAU,8BAA8BhB,MAASgC,EAAa,sBAAsBA,MAAiB,uBAAuB,EAAM5G,QAAgBwG,EACtK,MAAO,CACHxG,QACA4E,OACAgC,aACAC,IAAKd,EAAKA,EAAKvH,OAAS,GACxBuH,OACAY,YACGH,EACHZ,UAER,CAWO,SAAUkB,EAAWN,EAAQC,EAASC,EAAQ1G,IAhGrD,SAAoBA,GAChB,OAAOoG,EAASpG,IAA4C,mBAA3BA,EAAM+G,OAAOC,SAClD,EA+FSC,CAAWT,KAEZA,EAAS,CAACA,IAEd,IAAK,MAAMU,KAAoBV,EAAQ,CACnC,MAAMf,EAAUc,EAAUW,EAAkBT,EAASC,EAAQ1G,GACzDyF,UACMA,EAEd,CACJ,CAgBO,SAAU0B,EAAInH,EAAO0G,EAAQU,EAAU,CAAC,GAC3C,MAAM,KAAErB,EAAO,GAAE,OAAEY,EAAS,CAAC3G,GAAM,OAAEqH,GAAS,EAAK,KAAEC,GAAO,GAAUF,EAChEX,EAAU,CAAEV,OAAMY,UACxB,GAAIU,IAEArH,EAAQ0G,EAAOa,QAAQvH,EAAOyG,GAC1Ba,GACgB,SAAhBZ,EAAO9B,MACPwB,EAASM,EAAOc,SAChBpB,EAASpG,KACRjB,MAAMuB,QAAQN,IACf,IAAK,MAAM6G,KAAO7G,OACayH,IAAvBf,EAAOc,OAAOX,WACP7G,EAAM6G,GAK7B,IAAIa,EAAS,QACb,IAAK,MAAMjC,KAAWiB,EAAOiB,UAAU3H,EAAOyG,GAC1ChB,EAAQI,YAAcuB,EAAQxB,QAC9B8B,EAAS,iBACH,CAACjC,OAASgC,GAGpB,IAAK,IAAKG,EAAUC,EAAYC,KAAgBpB,EAAOqB,QAAQ/H,EAAOyG,GAAU,CAC5E,MAAMuB,EAAWb,EAAIU,EAAYC,EAAa,CAC1C/B,UAAmB0B,IAAbG,EAAyB7B,EAAO,IAAIA,EAAM6B,GAChDjB,YAAqBc,IAAbG,EAAyBjB,EAAS,IAAIA,EAAQkB,GACtDR,SACAC,OACA1B,QAASwB,EAAQxB,UAErB,IAAK,MAAMY,KAAUwB,EACbxB,EAAO,IACPkB,EAC6B,OAAzBlB,EAAO,GAAGI,iBAAgDa,IAAzBjB,EAAO,GAAGI,WACrC,YACA,mBACJ,CAACJ,EAAO,QAAIiB,IAEbJ,IACLQ,EAAarB,EAAO,QACHiB,IAAbG,EAEA5H,EAAQ6H,EAEH7H,aAAiBiI,IACtBjI,EAAMkI,IAAIN,EAAUC,GAEf7H,aAAiBmI,IACtBnI,EAAMoI,IAAIP,GAELzB,EAASpG,UACKyH,IAAfI,GAA4BD,KAAY5H,KACxCA,EAAM4H,GAAYC,GAKtC,CACA,GAAe,cAAXH,EACA,IAAK,MAAMjC,KAAWiB,EAAO2B,QAAQrI,EAAOyG,GACxChB,EAAQI,YAAcuB,EAAQxB,QAC9B8B,EAAS,mBACH,CAACjC,OAASgC,GAGT,UAAXC,SACM,MAACD,EAAWzH,GAE1B,CCjMO,MAAM,EACT,WAAA2B,CAAY2G,GACR,MAAM,KAAE1D,EAAI,OAAE4C,EAAM,UAAEG,EAAS,QAAEU,EAAO,QAAEd,EAAU,CAACvH,GAAUA,GAAK,QAAE+H,EAAU,YAEhF,GAAOO,EACPxJ,KAAK8F,KAAOA,EACZ9F,KAAK0I,OAASA,EACd1I,KAAKiJ,QAAUA,EACfjJ,KAAKyI,QAAUA,EAEXzI,KAAK6I,UADLA,EACiB,CAAC3H,EAAOyG,IAEdK,EADQa,EAAU3H,EAAOyG,GACNA,EAAS3H,KAAMkB,GAI5B,IAAM,GAGvBlB,KAAKuJ,QADLA,EACe,CAACrI,EAAOyG,IAEZK,EADQuB,EAAQrI,EAAOyG,GACJA,EAAS3H,KAAMkB,GAI9B,IAAM,EAE7B,CAIA,MAAAuI,CAAOvI,EAAO4F,GACV,OAAO2C,EAAOvI,EAAOlB,KAAM8G,EAC/B,CAIA,MAAA4C,CAAOxI,EAAO4F,GACV,OAgDD,SAAgB5F,EAAO0G,EAAQd,GAClC,MAAMY,EAAS,EAASxG,EAAO0G,EAAQ,CAAEW,QAAQ,EAAMzB,YACvD,GAAIY,EAAO,GACP,MAAMA,EAAO,GAGb,OAAOA,EAAO,EAEtB,CAxDe,CAAOxG,EAAOlB,KAAM8G,EAC/B,CAIA,EAAA6C,CAAGzI,GACC,OAAO,EAAGA,EAAOlB,KACrB,CAKA,IAAAwI,CAAKtH,EAAO4F,GACR,OAoDD,SAAc5F,EAAO0G,EAAQd,GAChC,MAAMY,EAAS,EAASxG,EAAO0G,EAAQ,CAAEW,QAAQ,EAAMC,MAAM,EAAM1B,YACnE,GAAIY,EAAO,GACP,MAAMA,EAAO,GAGb,OAAOA,EAAO,EAEtB,CA5Dec,CAAKtH,EAAOlB,KAAM8G,EAC7B,CASA,QAAA8C,CAAS1I,EAAOoH,EAAU,CAAC,GACvB,OAAO,EAASpH,EAAOlB,KAAMsI,EACjC,EASG,SAASmB,EAAOvI,EAAO0G,EAAQd,GAClC,MAAMY,EAAS,EAASxG,EAAO0G,EAAQ,CAAEd,YACzC,GAAIY,EAAO,GACP,MAAMA,EAAO,EAErB,CA0CO,SAAS,EAAGxG,EAAO0G,GAEtB,OADe,EAAS1G,EAAO0G,GAChB,EACnB,CAaO,SAAS,EAAS1G,EAAO0G,EAAQU,EAAU,CAAC,GAC/C,MAAMuB,EAASxB,EAAInH,EAAO0G,EAAQU,GAC5BwB,ED5FH,SAAuBC,GAC1B,MAAM,KAAEC,EAAI,MAAE9I,GAAU6I,EAAME,OAC9B,OAAOD,OAAOrB,EAAYzH,CAC9B,CCyFkBgJ,CAAcL,GAC5B,GAAIC,EAAM,GAAI,CAQV,MAAO,CAPO,IAAIpD,EAAYoD,EAAM,IAAI,YACpC,IAAK,MAAMK,KAAcN,EACjBM,EAAW,WACLA,EAAW,GAG7B,SACexB,EACnB,CAEA,MAAO,MAACA,EADemB,EAAM,GAEjC,CCvIO,SAAS,EAAOzC,EAAMwB,GACzB,OAAO,IAAI,EAAO,CAAE/C,KAAMuB,EAAMqB,OAAQ,KAAMG,aAClD,CCNO,SAASuB,EAAc/C,EAAMgD,GAChC,OAAO,EAAOhD,GAAOnG,GACO,iBAAVA,GAAsBmJ,EAAQC,KAAKpJ,IAEzD,CCjBO,MAAMqJ,EAAaH,EAAc,SAAU,2EAIrCI,EAAkBD,EAOlBE,EAAY,EAAO,OAAQvJ,IACpC,IACI,MAAMwJ,EAAM,IAAIC,IAAIzJ,GACpB,MAAwB,UAAjBwJ,EAAIE,UAAyC,WAAjBF,EAAIE,QAC3C,CACA,MACI,OAAO,CACX,KAKSC,EAAqBT,EAAc,eAAgB,kBCpBzD,SAASU,IACZ,OAAO,EAAO,OAAO,KAAM,GAC/B,CAWO,SAASC,EAAMC,GAClB,OAAO,IAAI,EAAO,CACdlF,KAAM,QACN4C,OAAQsC,EACR,QAAC/B,CAAQ/H,GACL,GAAI8J,GAAW/K,MAAMuB,QAAQN,GACzB,IAAK,MAAO+J,EAAOC,KAAehK,EAAM+H,eAC9B,CAACgC,EAAOC,EAAYF,EAGtC,EACA,OAAAvC,CAAQvH,GACJ,OAAOjB,MAAMuB,QAAQN,GAASA,EAAMY,QAAUZ,CAClD,EACA,SAAA2H,CAAU3H,GACN,OAAQjB,MAAMuB,QAAQN,IAClB,0CAA0C,EAAMA,IACxD,GAER,CAgBO,SAAS,IACZ,OAAO,EAAO,WAAYA,GACE,kBAAVA,GAEtB,CAwBO,SAASiK,EAAMC,GAClB,MAAM1C,EAAS,CAAC,EACV2C,EAAcD,EAAOzK,KAAKO,GAAU,EAAMA,KAAQiG,OACxD,IAAK,MAAMY,KAAOqD,EACd1C,EAAOX,GAAOA,EAElB,OAAO,IAAI,EAAO,CACdjC,KAAM,QACN4C,SACA,SAAAG,CAAU3H,GACN,OAAQkK,EAAO3E,SAASvF,IACpB,qBAAqBmK,sBAAgC,EAAMnK,IACnE,GAER,CA8BO,SAASoK,IACZ,OAAO,EAAO,WAAYpK,GACI,iBAAVA,IAAuBqK,MAAMrK,IAAUsF,OAAOgF,UAAUtK,IACpE,sCAAsC,EAAMA,MAExD,CAmCO,SAASuK,EAAQC,GACpB,MAAML,EAAc,EAAMK,GACpBC,SAAmBD,EACzB,OAAO,IAAI,EAAO,CACd5F,KAAM,UACN4C,OAAsB,WAAdiD,GACU,WAAdA,GACc,YAAdA,EACED,EACA,KACN,SAAA7C,CAAU3H,GACN,OAAQA,IAAUwK,GACd,0BAA0BL,sBAAgC,EAAMnK,IACxE,GAER,CAmCO,SAAS0K,IACZ,OAAO,EAAO,SAAS,KAAM,GACjC,CAOO,SAASC,EAASjE,GACrB,OAAO,IAAI,EAAO,IACXA,EACHiB,UAAW,CAAC3H,EAAO4K,IAAkB,OAAV5K,GAAkB0G,EAAOiB,UAAU3H,EAAO4K,GACrEvC,QAAS,CAACrI,EAAO4K,IAAkB,OAAV5K,GAAkB0G,EAAO2B,QAAQrI,EAAO4K,IAEzE,CAMO,SAASC,KACZ,OAAO,EAAO,UAAW7K,GACK,iBAAVA,IAAuBqK,MAAMrK,IACzC,oCAAoC,EAAMA,MAEtD,CAUO,SAAS,GAAOwH,GACnB,MAAMsD,EAAStD,EAAStJ,OAAOmH,KAAKmC,GAAU,GACxCuD,EAAQL,IACd,OAAO,IAAI,EAAO,CACd9F,KAAM,SACN4C,OAAQA,GAAU,KAClB,QAACO,CAAQ/H,GACL,GAAIwH,GAAUpB,EAASpG,GAAQ,CAC3B,MAAMgL,EAAW,IAAI7C,IAAIjK,OAAOmH,KAAKrF,IACrC,IAAK,MAAM6G,KAAOiE,EACdE,EAASC,OAAOpE,QACV,CAACA,EAAK7G,EAAM6G,GAAMW,EAAOX,IAEnC,IAAK,MAAMA,KAAOmE,OACR,CAACnE,EAAK7G,EAAM6G,GAAMkE,EAEhC,CACJ,EACA,SAAApD,CAAU3H,GACN,OAAQoG,EAASpG,IAAU,qCAAqC,EAAMA,IAC1E,EACA,OAAAuH,CAAQvH,GACJ,OAAOoG,EAASpG,GAAS,IAAKA,GAAUA,CAC5C,GAER,CAOO,SAAS,GAAS0G,GACrB,OAAO,IAAI,EAAO,IACXA,EACHiB,UAAW,CAAC3H,EAAO4K,SAAkBnD,IAAVzH,GAAuB0G,EAAOiB,UAAU3H,EAAO4K,GAC1EvC,QAAS,CAACrI,EAAO4K,SAAkBnD,IAAVzH,GAAuB0G,EAAO2B,QAAQrI,EAAO4K,IAE9E,CAeO,SAASM,GAAOC,EAAKC,GACxB,OAAO,IAAI,EAAO,CACdxG,KAAM,SACN4C,OAAQ,KACR,QAACO,CAAQ/H,GACL,GAAIoG,EAASpG,GAET,IAAK,MAAMqL,KAAarL,EAAO,CAC3B,MAAMsL,EAActL,EAAMqL,QACpB,CAACA,EAAWA,EAAWF,QACvB,CAACE,EAAWC,EAAaF,EACnC,CAER,EACA,SAAAzD,CAAU3H,GACN,OAAQoG,EAASpG,IAAU,qCAAqC,EAAMA,IAC1E,GAER,CA8CO,SAAS,KACZ,OAAO,EAAO,UAAWA,GACI,iBAAVA,GACX,oCAAoC,EAAMA,MAEtD,CA+DO,SAASuL,GAAMC,GAClB,MAAMrB,EAAcqB,EAAQ/L,KAAKiH,GAAWA,EAAO9B,OAAMqB,KAAK,OAC9D,OAAO,IAAI,EAAO,CACdrB,KAAM,QACN4C,OAAQ,KACR,OAAAD,CAAQvH,GACJ,IAAK,MAAMyL,KAAeD,EAAS,CAC/B,MAAOE,EAAOC,GAAWF,EAAY/C,SAAS1I,EAAO,CAAEqH,QAAQ,IAC/D,IAAKqE,EACD,OAAOC,CAEf,CACA,OAAO3L,CACX,EACA,SAAA2H,CAAU3H,EAAO4K,GACb,MAAMlF,EAAW,GACjB,IAAK,MAAM+F,KAAeD,EAAS,CAC/B,SAAU7C,GAAUxB,EAAInH,EAAOyL,EAAab,IACrCgB,GAASjD,EAChB,IAAKiD,IAAQ,GACT,MAAO,GAEX,IAAK,MAAOnG,KAAYkD,EAChBlD,GACAC,EAAStF,KAAKqF,EAG1B,CACA,MAAO,CACH,8CAA8C0E,sBAAgC,EAAMnK,QACjF0F,EAEX,GAER,CAMO,SAAS,KACZ,OAAO,EAAO,WAAW,KAAM,GACnC,CCzdO,SAAS,GAAO8B,GACnB,OAAO,GAASA,EACpB,CAkBA,SAASqE,GAAYjB,GAGjB,OAFiBA,EAAI7E,KAAK6E,EAAI7E,KAAKvH,OAAS,KAC7BoM,EAAIjE,OAAOiE,EAAIjE,OAAOnI,OAAS,EAElD,CAcO,SAASsN,GAAcpF,GAC1B,OAAO,IAAI,EAAO,IACXA,EACHiB,UAAW,CAAC3H,EAAO4K,KAASiB,GAAYjB,IAAQlE,EAAOiB,UAAU3H,EAAO4K,GACxEvC,QAAS,CAACrI,EAAO4K,KAASiB,GAAYjB,IAAQlE,EAAO2B,QAAQrI,EAAO4K,IAE5E,CAYO,SAASmB,GAAW/L,EAAO0G,EAAQd,GAEtC,OADA2C,EAAOvI,EAAO0G,EAAQd,GACf5F,CACX,CASO,SAASgM,GAAeC,GAC3B,OAAO,IAAI,EAAO,CACdrH,KAAM,QACN4C,OAAQ,KACR,QAACO,CAAQ/H,EAAOyG,SACLwF,EAASjM,GAAO+H,QAAQ/H,EAAOyG,EAC1C,EACA,QAAC4B,CAAQrI,EAAOyG,SACLwF,EAASjM,GAAOqI,QAAQrI,EAAOyG,EAC1C,EACA,OAAAc,CAAQvH,EAAOyG,GACX,OAAOwF,EAASjM,GAAOuH,QAAQvH,EAAOyG,EAC1C,EACA,SAAAkB,CAAU3H,EAAOyG,GAGb,OAAOwF,EAASjM,GAAO2H,UAAU3H,EAAOyG,EAC5C,GAER,CC5EO,SAASY,GAAOX,EAAQwF,EAAW3E,GACtC,OAAO,IAAI,EAAO,IACXb,EACHa,QAAS,CAACvH,EAAO4K,IACN,EAAG5K,EAAOkM,GACXxF,EAAOa,QAAQA,EAAQvH,EAAO4K,GAAMA,GACpClE,EAAOa,QAAQvH,EAAO4K,IAGxC,CCNA,SAASuB,GAAQnM,GACb,OAAIA,aAAiBiI,KAAOjI,aAAiBmI,IAClCnI,EAAMoM,KAEVpM,EAAMxB,MACjB,CAmDO,SAAS6N,GAAS3F,GACrB,OAAO4F,GAAO5F,EAAQ,YAAa1G,GAElBmM,GAAQnM,GACN,GAAK,uBAAuB0G,EAAO9B,kCAE1D,CA4DO,SAAS0H,GAAO5F,EAAQP,EAAMkC,GACjC,OAAO,IAAI,EAAO,IACX3B,EACH,QAAC2B,CAAQrI,EAAO4K,SACLlE,EAAO2B,QAAQrI,EAAO4K,GAC7B,MACMlF,EAAWoB,EADFuB,EAAQrI,EAAO4K,GACMA,EAAKlE,EAAQ1G,GACjD,IAAK,MAAMyF,KAAWC,OACZ,IAAKD,EAASmB,WAAYT,EAExC,GAER,CC9GO,MAAMoG,GAAc,CAACC,EAAerG,IAASjI,OAAOS,eAAeC,KAAK4N,EAAerG,GAkBvF,IAAIsG,IACX,SAAWA,GACPA,EAASA,EAAe,KAAI,GAAK,OACjCA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAkB,QAAI,GAAK,UACpCA,EAASA,EAAe,KAAI,GAAK,OACjCA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAgB,MAAI,GAAK,QAElCA,EAASA,EAAe,KAAI,IAAM,MACrC,CAVD,CAUGA,GAAWA,KAAaA,GAAW,CAAC,ICjEhC,MAAM,GAAUjF,GAIvB,GAAkBA,GASlB,SAAS,IAAY,KAAEzB,EAAI,OAAEY,IACzB,MAAM+F,EAAQ3G,EAAKA,EAAKvH,OAAS,GACjC,OAAO+N,GAAY5F,EAAOA,EAAOnI,OAAS,GAAIkO,EAClD,CA6BO,SAAS,GAAchG,GAC1B,OAAO,IAAI,EAAO,IACXA,EACH9B,KAAM,YAAY8B,EAAO9B,OACzB+C,UAAW,CAAC3H,EAAOyG,KAAa,GAAYA,IAAYC,EAAOiB,UAAU3H,EAAOyG,GAChF4B,QAAS,CAACrI,EAAOyG,KAAa,GAAYA,IAAYC,EAAO2B,QAAQrI,EAAOyG,IAEpF,CASA,SAASkG,GAAaC,GAClB,GAAa,OAATA,GAAiC,kBAATA,GAAsC,iBAATA,EACrD,OAAO,EAEX,GAAoB,iBAATA,GAAqBtH,OAAOuH,SAASD,GAC5C,OAAO,EAEX,GAAoB,iBAATA,EAAmB,CAC1B,IAAIE,GAAQ,EACZ,GAAI/N,MAAMuB,QAAQsM,GAAO,CAIrB,IAAK,IAAI1N,EAAI,EAAGA,EAAI0N,EAAKpO,OAAQU,IAC7B,IAAKyN,GAAaC,EAAK1N,IAAK,CACxB4N,GAAQ,EACR,KACJ,CAEJ,OAAOA,CACX,CACA,MAAM/E,EAAU7J,OAAO6J,QAAQ6E,GAI/B,IAAK,IAAI1N,EAAI,EAAGA,EAAI6I,EAAQvJ,OAAQU,IAEhC,GAA6B,iBAAlB6I,EAAQ7I,GAAG,KAAoByN,GAAa5E,EAAQ7I,GAAG,IAAK,CACnE4N,GAAQ,EACR,KACJ,CAEJ,OAAOA,CACX,CACA,OAAO,CACX,CAMO,MAAMC,GAAmB,EAAO,QAASH,GAASD,GAAaC,KAOzDI,GAAa3F,GAAO0F,GAAkBT,GAAO1C,IAAO,QAAS5J,GAAU,EAAGA,EAAO+M,OAAqB/M,GAAUqG,KAAK4G,MAAM5G,KAAKC,UAAUtG,GAAO,CAACkN,EAASC,KAEpK,GAAgB,cAAZD,GAAuC,gBAAZA,EAG/B,OAAOC,CAAS,OA+Cb,MACMC,GAAuB7C,EADZ,OAEX8C,GAAkB1C,EAASY,GAAM,CAACV,KAAU,QAC5CyC,GAAqB,GAAO,CACrCC,KAAMnD,IACNxE,QAAS,KACT4H,KAAM,GAAcR,IACpBS,MAAO,GAAc,QAEZC,GAAsBnC,GAAM,CAACL,GAAO,KAAU8B,IAAanD,EAAMmD,MAC1C,GAAO,CACvCW,GAAIN,GACJO,QAASR,GACTS,OAAQ,KACRC,OAAQ,GAAcJ,MAEe,GAAO,CAC5CE,QAASR,GACTS,OAAQ,KACRC,OAAQ,GAAcJ,MA+CkB,GAAkB,CAC1DC,GAAIN,GACJO,QAASR,GACT5G,OAAQ,GAAS,MACjBkF,MAAO,GAAS4B,MAJb,MAMMS,GAAuB,GAAO,CACvCJ,GAAIN,GACJO,QAASR,GACT5G,OAAQwG,KAECgB,GAAuB,GAAO,CACvCL,GAAIN,GACJO,QAASR,GACT1B,MAAO4B,KAE0B/B,GAAM,CACvCwC,GACAC,KC5PG,MAAM,GAAuB,GAAO,CACvCJ,QAASrD,EAAQ,OACjBoD,GAAIpC,GAAM,CAAC,KAAUV,KAAUN,EAAQ,QACvCsD,OAAQ,KACRC,OAAQhC,GAAcP,GAAM,CAAC1B,EAAMmD,IAAa9B,GAAO,KAAU8B,SCuC9D,MAAM,GAAc,CAACR,EAAerG,IAASjI,OAAOS,eAAeC,KAAK4N,EAAerG,GAkBvF,IAAI,IACX,SAAWsG,GACPA,EAASA,EAAe,KAAI,GAAK,OACjCA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAkB,QAAI,GAAK,UACpCA,EAASA,EAAe,KAAI,GAAK,OACjCA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAgB,MAAI,GAAK,QAElCA,EAASA,EAAe,KAAI,IAAM,MACrC,CAVD,CAUG,GAAW,KAAa,GAAW,CAAC,IAYhC,SAAS,GAAczM,GAC1B,GAAqB,iBAAVA,GAAgC,OAAVA,EAC7B,OAAO,EAEX,IACI,IAAIiO,EAAQjO,EACZ,KAAwC,OAAjC9B,OAAOgQ,eAAeD,IACzBA,EAAQ/P,OAAOgQ,eAAeD,GAElC,OAAO/P,OAAOgQ,eAAelO,KAAWiO,CAC5C,CACA,MAAOxK,GACH,OAAO,CACX,CACJ,CC3FO,MAAM,GAAU+D,GAIvB,GAAkBA,GASlB,SAAS,IAAY,KAAEzB,EAAI,OAAEY,IACzB,MAAM+F,EAAQ3G,EAAKA,EAAKvH,OAAS,GACjC,OAAO,GAAYmI,EAAOA,EAAOnI,OAAS,GAAIkO,EAClD,CA6BO,SAAS,GAAchG,GAC1B,OAAO,IAAI,EAAO,IACXA,EACH9B,KAAM,YAAY8B,EAAO9B,OACzB+C,UAAW,CAAC3H,EAAOyG,KAAa,GAAYA,IAAYC,EAAOiB,UAAU3H,EAAOyG,GAChF4B,QAAS,CAACrI,EAAOyG,KAAa,GAAYA,IAAYC,EAAO2B,QAAQrI,EAAOyG,IAEpF,CASA,SAAS,GAAamG,GAClB,GAAa,OAATA,GAAiC,kBAATA,GAAsC,iBAATA,EACrD,OAAO,EAEX,GAAoB,iBAATA,GAAqBtH,OAAOuH,SAASD,GAC5C,OAAO,EAEX,GAAoB,iBAATA,EAAmB,CAC1B,IAAIE,GAAQ,EACZ,GAAI/N,MAAMuB,QAAQsM,GAAO,CAIrB,IAAK,IAAI1N,EAAI,EAAGA,EAAI0N,EAAKpO,OAAQU,IAC7B,IAAK,GAAa0N,EAAK1N,IAAK,CACxB4N,GAAQ,EACR,KACJ,CAEJ,OAAOA,CACX,CACA,MAAM/E,EAAU7J,OAAO6J,QAAQ6E,GAI/B,IAAK,IAAI1N,EAAI,EAAGA,EAAI6I,EAAQvJ,OAAQU,IAEhC,GAA6B,iBAAlB6I,EAAQ7I,GAAG,KAAoB,GAAa6I,EAAQ7I,GAAG,IAAK,CACnE4N,GAAQ,EACR,KACJ,CAEJ,OAAOA,CACX,CACA,OAAO,CACX,CAMO,MAAM,GAAmB,EAAO,QAASF,GAAS,GAAaA,KAOzD,GAAavF,GAAO,GAAkBiF,GAAO1C,IAAO,QAAS5J,GAAU,EAAGA,EAAO,OAAqBA,GAAUqG,KAAK4G,MAAM5G,KAAKC,UAAUtG,GAAO,CAACkN,EAASC,KAEpK,GAAgB,cAAZD,GAAuC,gBAAZA,EAG/B,OAAOC,CAAS,OA+Cb,MACM,GAAuB5C,EADZ,OAEX,GAAkBI,EAASY,GAAM,CAACV,KAAU,QAC5C,GAAqB,GAAO,CACrC0C,KAAMnD,IACNxE,QAAS,KACT4H,KAAM,GAAc,IACpBC,MAAO,GAAc,QAEZ,GAAsBlC,GAAM,CAACL,GAAO,KAAU,IAAarB,EAAM,MAC1C,GAAO,CACvC8D,GAAI,GACJC,QAAS,GACTC,OAAQ,KACRC,OAAQ,GAAc,MAEe,GAAO,CAC5CF,QAAS,GACTC,OAAQ,KACRC,OAAQ,GAAc,MA+CkB,GAAkB,CAC1DH,GAAI,GACJC,QAAS,GACTpH,OAAQ,GAAS,MACjBkF,MAAO,GAAS,MAJb,MAMM,GAAuB,GAAO,CACvCiC,GAAI,GACJC,QAAS,GACTpH,OAAQ,KAEC,GAAuB,GAAO,CACvCmH,GAAI,GACJC,QAAS,GACTlC,MAAO,KAE0BH,GAAM,CACvC,GACA,KCzPG,IAAI4C,IACX,SAAWA,GAIPA,EAA0C,SAAI,WAI9CA,EAA4C,WAAI,aACnD,CATD,CASGA,KAAoCA,GAAkC,CAAC,IAInE,MAAMC,GAA6C,GAAO,CAI7DxJ,KAAM2F,EAAQ,GAAG4D,GAAgCE,YAIjDV,GAAI,KAIJW,eAAgB,KAOhBC,WAAY1D,OAKH2D,GAA+C,GAAO,CAI/D5J,KAAM2F,EAAQ,GAAG4D,GAAgCM,gBAKxCC,GAAqC1C,IAAgBhM,GACvD,GAAcA,IACjBA,EAAM4E,OAASuJ,GAAgCM,WAC7CD,GACAJ,KAwCGO,IT4CgBnD,GS5C2B,CAEpDN,GAAO,KAAU,KRhFA1D,GQwFZ,CAIDoH,QAAS9C,GAAc4C,IAIvBG,WAAY/C,GAAc,MTyS3B,SAActE,GACjB,MAAMnC,EAAOnH,OAAOmH,KAAKmC,GACzB,OAAO,IAAI,EAAO,CACd5C,KAAM,OACN4C,SACA,QAACO,CAAQ/H,GACL,GAAIoG,EAASpG,GACT,IAAK,MAAMkE,KAAKmB,OACN,CAACnB,EAAGlE,EAAMkE,GAAIsD,EAAOtD,GAGvC,EACA,SAAAyD,CAAU3H,GACN,OAAQoG,EAASpG,IAAU,qCAAqC,EAAMA,IAC1E,EACA,OAAAuH,CAAQvH,GACJ,OAAOoG,EAASpG,GAAS,IAAKA,GAAUA,CAC5C,GAER,CC3ZW,CAAOwH,MD0HP,IAAI,EAAO,CACd5C,KAAM,eACN4C,OAAQ,KACR,QAACO,CAAQ/H,EAAOyG,GACZ,IAAK,MAAM,QAAEsB,KAAayD,SACfzD,EAAQ/H,EAAOyG,EAE9B,EACA,UAACkB,CAAU3H,EAAOyG,GACd,IAAK,MAAM,UAAEkB,KAAe6D,SACjB7D,EAAU3H,EAAOyG,EAEhC,EACA,QAAC4B,CAAQrI,EAAOyG,GACZ,IAAK,MAAM,QAAE4B,KAAamD,SACfnD,EAAQrI,EAAOyG,EAE9B,KAlBD,IAAsB+E,GC1HRhE,GSDd,SAAS,GAAcrB,EAAMgD,GAChC,OAAO,EAAOhD,GAAOnG,GACO,iBAAVA,GAAsBmJ,EAAQC,KAAKpJ,IAEzD,CCpBO,MAAM8O,GAAsB,oEACtBC,GAAuB,oBACvBC,GAAuB,yBACvBC,GAAwB,yHACxBC,GAA6B,2BAC7BC,GAA6B,oBAC7BC,GAA6B,2BAC7BC,GAAsB,0BACtBC,GAAwB,4JACxBC,GAAsB,8LAKtBC,GAAoB,GAAc,cAAeV,IAYjDW,IARsB,GAAc,gBAAiBV,IAI/B,GAAc,gBAAiBC,IAI/B,GAAc,gBAAiBC,KAoBrDS,IAhB2B,GAAc,qBAAsBR,IAIpC,GAAc,qBAAsBC,IAIpC,GAAc,qBAAsBC,IAI3C,GAAc,cAAeC,IAI3B,GAAc,gBAAiBC,KAIrDK,GAAoB,GAAc,cAAeJ,IAIjDK,GAA0B,GAAc,oBA5CjB,kMA8C7B,IAAIC,GCnDA,GAQAC,GAUAC,GAOAC,GAQAC,IDmBX,SAAWJ,GAEPA,EAA2B,OAAI,SAE/BA,EAA2B,OAAI,SAE/BA,EAA2B,OAAI,SAC/BA,EAA2B,OAAI,QAClC,CARD,CAQGA,GAAqBA,KAAuBA,GAAqB,CAAC,IC3DrE,SAAWK,GACPA,EAAoB,IAAI,aACxBA,EAAwB,QAAI,gBAC/B,CAHD,CAGG,KAAmB,GAAiB,CAAC,IAKxC,SAAWJ,GACPA,EAAsB,MAAI,eAC1BA,EAAqB,KAAI,cACzBA,EAAuB,OAAI,gBAC3BA,EAAqB,KAAI,aAC5B,CALD,CAKGA,KAAmBA,GAAiB,CAAC,IAKxC,SAAWC,GACPA,EAA4B,YAAI,qBACnC,CAFD,CAEGA,KAAmBA,GAAiB,CAAC,IAKxC,SAAWC,GACPA,EAAoB,IAAI,UAC3B,CAFD,CAEGA,KAAmBA,GAAiB,CAAC,IAMxC,SAAWC,GACPA,EAAwB,QAAI,aAC/B,CAFD,CAEGA,KAAmBA,GAAiB,CAAC,IAQjC,MAAME,GAAuB,GAAO,CAIvCxC,GAAIrE,EAIJ1E,KAAMqF,EAAM,CACR,GAAG,GAAemG,MAClB,GAAG,GAAeC,UAClB,GAAGP,GAAeQ,QAClB,GAAGR,GAAeS,OAClB,GAAGT,GAAeU,SAClB,GAAGV,GAAeW,OAClB,GAAGV,GAAeW,cAClB,GAAGV,GAAeI,MAClB,GAAGH,GAAeU,YAKtBxL,QAAS,KAITyL,OAAQvE,GAASxC,EAAM2F,KAIvBpI,QAASuH,GAITkC,QAAShH,EAAM,QC/ENiH,ICD+B,GAAO,CAI/C3L,QAASsK,KDH4B,GAAO,CAI5CsB,KAAM,KAINC,OAAQrH,KAKCsH,GAAsB,GAAO,CAItCC,SAAU3G,GAAQ,GAIlB3F,KAAM8K,MACHoB,GAA0BtJ,SAKpB2J,GAAyB,GAAO,CAIzCD,SAAU3G,GAAQ,GAIlBoD,GAAIgC,KAsCKyB,GAAcpF,IAAgBhM,GAChC,GAAcA,KAAWA,EAAMkR,SAChCC,GACAF,KEhFGI,GAAgB,GAAO,CAChCL,OAAQrH,EACRoH,KAAM,OCHGO,GAAuB,GAAc,iBAAkB,oBCQ7D,IAAIC,IACX,SAAWA,GAEPA,EAA6B,MAAI,OACpC,CAHD,CAGGA,KAA0BA,GAAwB,CAAC,IAO/C,MAeMC,GAf+B,GAAO,CAI/C5M,KAAM2F,EAAQ,GAAGgH,GAAsBE,SAIvCb,OAAQ/G,EAAM2F,IAIdlB,eAAgBgD,KC9BPI,GAA2BxG,GAAO,KAAU,ICC5CyG,GAAuB,GAAO,CAIvChE,GAAItE,EAIJuI,MAAO,KAIPC,QAASxI,EAITyI,OAAQ,KAIRC,QAAS,GAAO,CACZlE,OAAQ,KACRC,OAAQhC,GAAcP,GAAM,CAAC1B,EAAM,IAAaqB,GAAO,KAAU,WCtB5D8G,GAAwBzG,GAAM,CACvC,GAAO,CAQH0G,QAAS1H,GAAQ,GAQjB2H,SAAUpG,GAAc,GAAO,CAC3BlG,QAASkG,GAAc,MACvBtC,IAAKsC,GAAc,WAG3B,GAAO,CAQHmG,QAAS1H,GAAQ,GAIjB/D,OAAQ,OCEV2L,GAAoB,GAAO,CAI7BhN,QAAS,KAITiN,MAAOzH,EAASyG,MAKb,IAAIiB,IACX,SAAWA,GAQPA,EAAc,KAAI,OAOlBA,EAAkB,SAAI,UACzB,CAhBD,CAgBGA,KAAYA,GAAU,CAAC,IAI1B,MAAMC,GAAY,GAAO,CAIrB1N,KAAMqF,EAAM,CAAC,GAAGoI,GAAQE,OAAQ,GAAGF,GAAQG,aAI3CJ,MAAOhB,KAKJ,IAAIqB,GAwBAC,IAvBX,SAAWD,GAKPA,EAA6B,UAAI,YAKjCA,EAA+B,YAAI,cAInCA,EAA6B,UAAI,YAIjCA,EAA0B,OAAI,QACjC,CAnBD,CAmBGA,KAAsBA,GAAoB,CAAC,IAK9C,SAAWC,GAMPA,EAAsB,KAAI,OAK1BA,EAAyB,QAAI,UAO7BA,EAAsB,KAAI,OAK1BA,EAA4B,WAAI,cAKhCA,EAA+B,cAAI,iBAKnCA,EAAyB,QAAI,SAChC,CAlCD,CAkCGA,KAAoBA,GAAkB,CAAC,IAInC,MAAMC,GAAyB,GAAO,CAIzCjL,OAAQuC,EAAM,CACV,GAAGwI,GAAkBG,YACrB,GAAGH,GAAkBI,cACrB,GAAGJ,GAAkBK,YACrB,GAAGL,GAAkBM,WAKzBC,UAAWrI,EAASE,QA2DXoI,GAAoB,GAAO,CAIpCtF,GAAI,KAIJuF,MAAO1D,GAIPqC,QAASxI,EAIT3B,OAAQuC,EAAM,CACV,GAAGwI,GAAkBG,YACrB,GAAGH,GAAkBI,cACrB,GAAGJ,GAAkBK,YACrB,GAAGL,GAAkBM,WAOzBC,UAAWrI,EAASE,MAKpBjG,KAAMqF,EAAM,CACR,GAAGyI,GAAgBS,OACnB,GAAGT,GAAgBU,UACnB,GAAGV,GAAgBW,OACnB,GAAGX,GAAgBY,aACnB,GAAGZ,GAAgBa,gBACnB,GAAGb,GAAgBc,YAKvBC,KAAM5J,EAAMsI,IAIZuB,GAAI7J,EAAMsI,IAIVwB,KAAM9J,EAAMyI,IAOZsB,OAAQ/J,EAAM8I,MA6BLkB,GAAyB,GAAO,CAIzCrG,KAAM3D,EAAMoJ,IAKZlK,KAAM4B,EAAS,QC/SNmJ,GAAmB,GAAO,CAInCC,MAAOlJ,KAIP9B,KAAM+C,GAAcnB,EAAS,SCrBpBqJ,GAAwB,GAAO,CAKxCC,SAAUnI,GAAc,GAAO,CAI3BoI,cAAe7K,OCNhB,IAAI8K,IACX,SAAWA,GACPA,EAAkB,QAAI,0CACtBA,EAAkB,QAAI,0CACtBA,EAAmB,SAAI,0CACvBA,EAAiB,OAAI,0CACrBA,EAAkB,QAAI,gBACzB,CAND,CAMGA,KAAaA,GAAW,CAAC,ICP5B,MAAMC,GAAkB,CAACjP,EAASP,KAC9B,IAEI,OADoB,EAAeO,GACnBP,OAASA,GAGlB,IAAIxF,MAAM,WAAWwF,YAChC,CACA,MAAO8G,GACH,OAAO,IAAItM,MAAM,oBAAoBwF,cAAiB8G,EAAM9F,UAChE,GAESyO,GAAwB/H,GAAO,KAAU,yBAA0BnH,GACrEiP,GAAgBjP,EAAS,EAAYZ,SAEnC+P,GAAuBhI,GAAO,KAAU,wBAAyBnH,GACnEiP,GAAgBjP,EAAS,EAAYX,QAEnC+P,GAAyBjI,GAAO,KAAU,0BAA2BnH,GACvEiP,GAAgBjP,EAAS,EAAYV,UAEnC+P,GAAuBlI,GAAO,KAAU,wBAAyBnH,GACnEiP,GAAgBjP,EAAS,EAAYR,QAKzC,IAAI8P,IACX,SAAWA,GACPA,EAAoB,SAAI,WACxBA,EAAsB,WAAI,aAC1BA,EAAoB,SAAI,WACxBA,EAAyB,cAAI,gBAC7BA,EAAwB,aAAI,eAC5BA,EAAmB,QAAI,UACvBA,EAAqB,UAAI,YACzBA,EAA4B,iBAAI,mBAChCA,EAAuB,YAAI,aAC9B,CAVD,CAUGA,KAAcA,GAAY,CAAC,IAC9B,MAAMC,GAAmB,GAAO,IACzBvE,GAAqB3I,OAIxBoJ,OAAQvE,GAASxC,EAAM2F,KAIvBqB,QAAShH,EAAMI,EAAM/L,OAAOgM,OAAOuK,QAEF,GAAO,IACrCC,GAAiBlN,OAIpBrC,QAASkP,GAITzP,KAAM2F,EAAQ,GAAGuF,GAAeQ,WAEA,GAAO,IACpCoE,GAAiBlN,OAIpBrC,QAASmP,GAIT1P,KAAM2F,EAAQ,GAAGuF,GAAeS,UAEE,GAAO,IACtCmE,GAAiBlN,OAIpBrC,QAASoP,GAIT3P,KAAM2F,EAAQ,GAAGuF,GAAeU,YAEA,GAAO,IACpCkE,GAAiBlN,OAIpBrC,QAASqP,GAIT5P,KAAM2F,EAAQ,GAAGuF,GAAeW,UC5F7B,IAAIkE,IACX,SAAWA,GACPA,EAAiB,OAAI,0CACrBA,EAAkB,QAAI,0CACtBA,EAAkB,QAAI,yCACzB,CAJD,CAIGA,KAAaA,GAAW,CAAC,ICArB,MAAMC,GAAmB,GAAc,aAAc,mCAIrD,IAAIC,IACX,SAAWA,GAIPA,EAAqC,0BAAI,4BACzCA,EAAkC,uBAAI,yBACtCA,EAA2B,gBAAI,kBAC/BA,EAAuB,YAAI,cAC3BA,EAAkB,OAAI,QACzB,CATD,CASGA,KAAcA,GAAY,CAAC,IACM,GAAO,IACpC1E,GAAqB3I,OAIxBrC,QAASyP,GAIThQ,KAAM2F,EAAQ,GAAGwF,GAAeW,eAIhCE,OAAQvE,GAASxC,EAAM2F,KAIvBqB,QAAShH,EAAMI,EAAM/L,OAAOgM,OAAO2K,QCrChC,IAAIC,IACX,SAAWA,GACPA,EAAc,IAAI,WAClBA,EAAkB,QAAI,WACtBA,EAAkB,QAAI,iBACzB,CAJD,CAIGA,KAAaA,GAAW,CAAC,ICJrB,MAAMC,GAAiB,GAAc,WAAY,mBAC3CC,GAAmB,GAAc,aAAc,sBAC/CC,GAAmB,GAAc,aAAc,+BAIrD,IAAIC,IACX,SAAWA,GAEPA,EAAwB,aAAI,gBAC5BA,EAAgB,KAAI,WACpBA,EAA2B,gBAAI,sBAC/BA,EAA2B,gBAAI,uBAC/BA,EAA2B,gBAAI,uBAC/BA,EAA2B,gBAAI,uBAE/BA,EAAgC,qBAAI,2BACpCA,EAA8B,mBAAI,yBAClCA,EAA6B,kBAAI,uBACpC,CAZD,CAYGA,KAAcA,GAAY,CAAC,IACK,GAAO,IACnC/E,GAAqB3I,OAIxBrC,QAAS6P,GAITpQ,KAAM2F,EAAQ,GAAG,GAAe6F,OAIhCQ,OAAQvE,GAASxC,EAAMU,EAAQuK,GAAS1E,OAIxCS,QAAShH,EAAMI,EAAM,CACjB,GAAGiL,GAAUC,eACb,GAAGD,GAAUE,OACb,GAAGF,GAAUG,kBACb,GAAGH,GAAUI,kBACb,GAAGJ,GAAUK,kBACb,GAAGL,GAAUM,uBAGkB,GAAO,IACvCrF,GAAqB3I,OAIxBrC,QAAS6P,GAITpQ,KAAM2F,EAAQ,GAAG,GAAe8F,WAIhCO,OAAQvE,GAASxC,EAAM2F,KAIvBqB,QAAShH,EAAMI,EAAM,CACjB,GAAGiL,GAAUC,eACb,GAAGD,GAAUE,OACb,GAAGF,GAAUI,kBACb,GAAGJ,GAAUK,kBACb,GAAGL,GAAUM,kBACb,GAAGN,GAAUO,uBACb,GAAGP,GAAUQ,qBACb,GAAGR,GAAUS,yBCrEiB,GAAO,CACzCC,OAAQZ,GACRa,MAAOZ,GACPa,SAAUf,GACVgB,SAAUhB,GACViB,aAAcf,GACdgB,qBAAsBhB,GACtBiB,mBAAoBjB,GACpBkB,aAAclB,GACdmB,qBAAsBnB,GACtBoB,iBAAkBtB,GAClBuB,UAAWvB,KAMyB,GAAO,CAI3CrB,GAAIsB,GAIJhV,MAAOiV,GAIPzH,KAAMuH,KAEgC,GAAO,CAC7Cc,MAAOZ,GACPa,SAAUf,GACVgB,SAAUhB,GACVwB,UAAWzK,GAAc,GAAO,CAC5BkK,aAAcf,GACdgB,qBAAsBhB,GACtBiB,mBAAoBjB,MAExBuB,sBAAuBzB,GACvB0B,eAAgB1B,GAChB2B,WAAYnN,IAE2B,GAAO,CAC9C8M,iBAAkBtB,GAClBiB,aAAclK,GAAcmJ,IAC5BgB,qBAAsBnK,GAAcmJ,IACpCiB,mBAAoBpK,GAAcmJ,MCnD/B,IAAI0B,IACX,SAAWA,GACPA,EAAkB,QAAI,iBACtBA,EAAe,KAAI,kBACnBA,EAAiB,OAAI,iBACxB,CAJD,CAIGA,KAAaA,GAAW,CAAC,ICDrB,MAAMC,GAAmB,GAAc,aAAc,iCAIrD,IAAIC,IACX,SAAWA,GACPA,EAAyB,cAAI,gBAC7BA,EAA2B,gBAAI,iBAClC,CAHD,CAGGA,KAAcA,GAAY,CAAC,IACK,GAAO,IACnC1G,GAAqB3I,OAIxBrC,QAASyR,GAIThS,KAAM2F,EAAQ,GAAGyF,GAAeI,OAIhCQ,OAAQvE,GAASxC,EAAM2F,KAIvBqB,QAAShH,EAAMI,EAAM/L,OAAOgM,OAAO2M,QC3BhC,IAAIC,IACX,SAAWA,GACPA,EAA+B,aAAI,uBACnCA,EAA6B,WAAI,qBACjCA,EAAgC,cAAI,wBACpCA,EAAmC,iBAAI,2BACvCA,EAAoC,kBAAI,4BACxCA,EAA0C,wBAAI,kCAC9CA,EAAqC,mBAAI,6BACzCA,EAAwC,sBAAI,gCAC5CA,EAAsC,oBAAI,8BAC1CA,EAAgC,cAAI,wBACpCA,EAAgC,cAAI,wBACpCA,EAAgC,cAAI,wBACpCA,EAA+B,aAAI,uBACnCA,EAA6B,WAAI,qBACjCA,EAAgC,cAAI,wBACpCA,EAAiC,eAAI,yBACrCA,EAAgC,cAAI,uBACvC,CAlBD,CAkBGA,KAAqBA,GAAmB,CAAC,IAW5C,MAAMC,GAAe,CACjBnJ,QAASrD,EAAQ,OACjBoD,GAAIpC,GAAM,CAAC,KAAUV,KAAUN,EAAQ,SAQ9ByM,IAJ4B,GAAO,IACzCD,GACHlJ,OAAQtD,EAAQ,0BAEsBV,EAAMsG,KAUnC8G,IAP0B,GAAO,IACvCF,GACHlJ,OAAQtD,EAAQ,sBAChBuD,OAAQ,GAAO,CACXH,GAAItE,MAG4B8G,IAU3B+G,IAP6B,GAAO,IAC1CH,GACHlJ,OAAQtD,EAAQ,yBAChBuD,OAAQ,GAAO,CACX1G,QAAS8D,GAAO,KAAU,QAGSiF,IAY9BgH,IATgC,GAAO,IAC7CJ,GACHlJ,OAAQtD,EAAQ,4BAChBuD,OAAQ,GAAO,CACX8C,OAAQ/G,EAAM2F,IACd4H,cAAe,KACf7I,WAAY1D,SAG0BhB,EAAM2H,KAWvC6F,IARuC,GAAO,IACpDN,GACHlJ,OAAQtD,EAAQ,mCAChBuD,OAAQ,GAAO,CACXH,GAAItE,EACJiO,WAAYxD,OAGiCD,IAUxC0D,IAPiC,GAAO,IAC9CR,GACHlJ,OAAQtD,EAAQ,6BAChBuD,OAAQ,GAAO,CACXH,GAAItE,MAGmCQ,EAAM+F,KAWxC4H,IARkC,GAAO,IAC/CT,GACHlJ,OAAQtD,EAAQ,GAAGuM,GAAiBW,sBACpC3J,OAAQ,GAAO,CACXH,GAAItE,EACJqO,OAAQ7N,EAAM6F,QAG0BxE,GAAOwE,GAAqB2B,KAW/DsG,IARqC,GAAO,IAClDZ,GACHlJ,OAAQtD,EAAQ,iCAChBuD,OAAQ,GAAO,CACX8D,MAAOpC,GACPuC,QAAS,OAGkCpH,EAAS,GAAO,CAC/DxF,QAASsK,OAYAmI,IAR4B,GAAO,IACzCb,GACHlJ,OAAQtD,EAAQ,+BAChBuD,OAAQ,GAAO,CACXH,GAAItE,EACJwO,OAAQhO,EAAM,UAG2BA,EAAM,OAU1CiO,IAP6B,GAAO,IAC1Cf,GACHlJ,OAAQtD,EAAQ,yBAChBuD,OAAQ,GAAO,CACX+D,QAAS1B,OAG0B5F,EAAQ,OAUtCwN,IAP6B,GAAO,IAC1ChB,GACHlJ,OAAQtD,EAAQ,yBAChBuD,OAAQ,GAAO,CACXH,GAAItE,MAG+BkB,EAAQ,OAUtCyN,IAP6B,GAAO,IAC1CjB,GACHlJ,OAAQtD,EAAQ,yBAChBuD,OAAQ,GAAO,CACXH,GAAItE,MAG+BqI,IAO9BuG,IAJ4B,GAAO,IACzClB,GACHlJ,OAAQtD,EAAQ,0BAEsBV,EAAM8H,KAUnCuG,IAP0B,GAAO,IACvCnB,GACHlJ,OAAQtD,EAAQ,sBAChBuD,OAAQ,GAAO,CACXH,GAAItE,MAG4BsI,IAQ3BwG,IAL6B,GAAO,IAC1CpB,GACHlJ,OAAQtD,EAAQ,yBAChBuD,OAAQ6D,KAE+BK,IAW9BoG,IAR8B,GAAO,IAC3CrB,GACHlJ,OAAQtD,EAAQ,0BAChBuD,OAAQ,GAAO,CACXH,GAAItE,EACJmE,KAAMtC,GAAO,KAAU,QAGaX,EAAQ,OAUvC8N,IAP6B,GAAO,IAC1CtB,GACHlJ,OAAQtD,EAAQ,yBAChBuD,OAAQ,GAAO,CACXH,GAAItE,MAG+BkB,EAAQ,OC1M5C,IAAI+N,IACX,SAAWA,GAEPA,EAA6B,eAAI,wBACjCA,EAA6B,eAAI,wBACjCA,EAA6B,eAAI,wBAEjCA,EAA8B,gBAAI,yBAClCA,EAA8B,gBAAI,yBAElCA,EAAqC,uBAAI,gCACzCA,EAAsC,wBAAI,iCAC1CA,EAAyC,2BAAI,mCAChD,CAZD,CAYGA,KAAiBA,GAAe,CAAC,IACK,GAAO,CAC5CzK,OAAQtD,EAAQ,GAAG+N,GAAaC,kBAChCzK,OAAQ,GAAO,CAIX+D,QAAS1B,GAQTqI,sBAAuB1M,GAAc,MAMrC2M,oBAAqB3M,GAAc,KASnC4M,6BAA8B5M,GAAc,QAIzCkI,GAAsBxM,WAGQ,GAAO,CAC5CqG,OAAQtD,EAAQ,GAAG+N,GAAaK,kBAChC7K,OAAQ,GAAO,CAIX+D,QAAS1B,OAGwB,GAAO,CAC5CtC,OAAQtD,EAAQ,GAAG+N,GAAaM,kBAChC9K,OAAQ,GAAO,CAIXH,GAAItE,MAG8B,GAAO,CAC7CwE,OAAQtD,EAAQ,GAAG+N,GAAaO,mBAChC/K,OAAQ,GAAO,CAIXH,GAAItE,EAIJ7C,OAAQ,OAG0B,GAAO,CAC7CqH,OAAQtD,EAAQ,GAAG+N,GAAaQ,mBAChChL,OAAQ,GAAO,CAIXH,GAAItE,MAYqC,GAAO,CACpDwE,OAAQtD,EAAQ,GAAG+N,GAAaS,0BAChCjL,OAAQ,GAAO,CAIXkL,SAAU9N,GAIV5B,EAIA4B,GAIAwE,GAIAoB,SAW6C,GAAO,CACxDjD,OAAQtD,EAAQ,GAAG+N,GAAaW,8BAChCnL,OAAQ,GAAO,CAIXoL,aAAchO,GAId5B,EAIAO,EAAMoJ,SAUoC,GAAO,CACrDpF,OAAQtD,EAAQ,GAAG+N,GAAaa,2BAChCrL,OAAQ,GAAO,CAIX4J,OAAQxM,GAIR5B,EAIA,GAAO,CAIH8P,MAAOvP,EAAM+F,IAIbyJ,QAASxP,EAAM+F,WC1L3B,QACE0J,WAFmC,oBAAXC,QAA0BA,OAAOD,YAAcC,OAAOD,WAAWE,KAAKD,SCGhG,IAAIE,GACJ,MAAMC,GAAQ,IAAIla,WAAW,IACd,SAASma,KAEtB,IAAKF,KAEHA,GAAoC,oBAAXF,QAA0BA,OAAOE,iBAAmBF,OAAOE,gBAAgBD,KAAKD,SAEpGE,IACH,MAAM,IAAIra,MAAM,4GAIpB,OAAOqa,GAAgBC,GACzB,CCXA,MAAME,GAAY,GAElB,IAAK,IAAI1a,GAAI,EAAGA,GAAI,MAAOA,GACzB0a,GAAUxZ,MAAMlB,GAAI,KAAO4E,SAAS,IAAIlD,MAAM,IAGzC,SAASiZ,GAAgBC,EAAKC,EAAS,GAG5C,OAAOH,GAAUE,EAAIC,EAAS,IAAMH,GAAUE,EAAIC,EAAS,IAAMH,GAAUE,EAAIC,EAAS,IAAMH,GAAUE,EAAIC,EAAS,IAAM,IAAMH,GAAUE,EAAIC,EAAS,IAAMH,GAAUE,EAAIC,EAAS,IAAM,IAAMH,GAAUE,EAAIC,EAAS,IAAMH,GAAUE,EAAIC,EAAS,IAAM,IAAMH,GAAUE,EAAIC,EAAS,IAAMH,GAAUE,EAAIC,EAAS,IAAM,IAAMH,GAAUE,EAAIC,EAAS,KAAOH,GAAUE,EAAIC,EAAS,KAAOH,GAAUE,EAAIC,EAAS,KAAOH,GAAUE,EAAIC,EAAS,KAAOH,GAAUE,EAAIC,EAAS,KAAOH,GAAUE,EAAIC,EAAS,IAChf,CCYA,ICjBIC,GDiBJ,GAxBA,SAAY5S,EAAS6S,EAAKF,GACxB,GAAI,GAAOT,aAAeW,IAAQ7S,EAChC,OAAO,GAAOkS,aAIhB,MAAMY,GADN9S,EAAUA,GAAW,CAAC,GACD+S,SAAW/S,EAAQuS,KAAOA,MAK/C,GAHAO,EAAK,GAAe,GAAVA,EAAK,GAAY,GAC3BA,EAAK,GAAe,GAAVA,EAAK,GAAY,IAEvBD,EAAK,CACPF,EAASA,GAAU,EAEnB,IAAK,IAAI7a,EAAI,EAAGA,EAAI,KAAMA,EACxB+a,EAAIF,EAAS7a,GAAKgb,EAAKhb,GAGzB,OAAO+a,CACT,CAEA,OAAOJ,GAAgBK,EACzB,EC1BIE,GAAkE,SAAUC,EAAUC,EAAOta,EAAOua,EAAM/Z,GAC1G,GAAa,MAAT+Z,EAAc,MAAM,IAAInZ,UAAU,kCACtC,GAAa,MAATmZ,IAAiB/Z,EAAG,MAAM,IAAIY,UAAU,iDAC5C,GAAqB,mBAAVkZ,EAAuBD,IAAaC,IAAU9Z,GAAK8Z,EAAME,IAAIH,GAAW,MAAM,IAAIjZ,UAAU,2EACvG,MAAiB,MAATmZ,EAAe/Z,EAAE5B,KAAKyb,EAAUra,GAASQ,EAAIA,EAAER,MAAQA,EAAQsa,EAAMpS,IAAImS,EAAUra,GAASA,CACxG,EACIya,GAAkE,SAAUJ,EAAUC,EAAOC,EAAM/Z,GACnG,GAAa,MAAT+Z,IAAiB/Z,EAAG,MAAM,IAAIY,UAAU,iDAC5C,GAAqB,mBAAVkZ,EAAuBD,IAAaC,IAAU9Z,GAAK8Z,EAAME,IAAIH,GAAW,MAAM,IAAIjZ,UAAU,4EACvG,MAAgB,MAATmZ,EAAe/Z,EAAa,MAAT+Z,EAAe/Z,EAAE5B,KAAKyb,GAAY7Z,EAAIA,EAAER,MAAQsa,EAAMI,IAAIL,EACxF,EAMO,MAAMM,GAMT,WAAAhZ,CAAYiU,GACRoE,GAAsB9R,IAAIpJ,UAAM,GAChCsb,GAAuBtb,KAAMkb,GAAuBpE,EAAQ,IAChE,CAOA,UAAMgF,CAAKC,GACP,OAAOJ,GAAuB3b,KAAMkb,GAAuB,KAAKY,KAAK,CACjEhN,QAAS,MACTD,GAAI,QACDkN,GAEX,CACA,kBAAMC,GACF,OAAO/O,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiBiE,eACzB/D,GACR,CACA,gBAAMgE,CAAWrN,GACb,OAAO5B,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiBmE,WACzBnN,OAAQ,CAAEH,QACVsJ,GACR,CACA,wBAAMiE,CAAmBvN,EAAI+J,GACzB,OAAO3L,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiBW,mBACzB3J,OAAQ,CAAEH,KAAI+J,YACdF,GACR,CACA,mBAAM2D,CAAc/T,EAAU,CAAC,GAC3B,OAAO2E,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiBsE,cACzBtN,OAAQ,CAAE1G,aACV8P,GACR,CACA,sBAAMmE,CAAiBzK,EAAQwG,EAAe7I,GAC1C,OAAOxC,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiBwE,iBACzBxN,OAAQ,CAAE8C,SAAQwG,gBAAe7I,gBACjC4I,GACR,CACA,6BAAMoE,CAAwB5N,EAAI2J,GAC9B,OAAOvL,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiB0E,wBACzB1N,OAAQ,CAAEH,KAAI2J,gBACdD,GACR,CACA,uBAAMoE,CAAkB9N,GACpB,OAAO5B,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiB4E,kBACzB5N,OAAQ,CAAEH,QACV4J,GACR,CACA,2BAAMoE,CAAsB/J,EAAOG,GAC/B,OAAOhG,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiB8E,sBACzB9N,OAAQ,CAAE8D,QAAOG,aACjB4F,GACR,CACA,yBAAMkE,CAAoBlO,EAAIkK,GAC1B,OAAO9L,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiBgF,oBACzBhO,OAAQ,CAAEH,KAAIkK,YACdD,GACR,CACA,mBAAMmE,CAAclK,GAChBtJ,QAAazJ,KAAK8b,KAAK,CACnB/M,OAAQiJ,GAAiBkF,cACzBlO,OAAQ,CAAE+D,aACViG,GACR,CACA,mBAAMmE,CAActO,GAChBpF,QAAazJ,KAAK8b,KAAK,CACnB/M,OAAQiJ,GAAiBoF,cACzBpO,OAAQ,CAAEH,QACVoK,GACR,CACA,mBAAMoE,CAAcxO,GAChB,OAAO5B,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiBsF,cACzBtO,OAAQ,CAAEH,QACVqK,GACR,CACA,kBAAMqE,GACF,OAAOtQ,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiBwF,eACzBrE,GACR,CACA,gBAAMsE,CAAW5O,GACb,OAAO5B,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiB0F,WACzB1O,OAAQ,CAAEH,QACVuK,GACR,CACA,mBAAMuE,CAAc1K,GAChB,OAAOhG,SAAiBjN,KAAK8b,KAAK,CAC9B/M,OAAQiJ,GAAiB4F,cACzB5O,OAAQiE,IACRoG,GACR,CACA,oBAAMwE,CAAehP,EAAIH,EAAO,CAAC,GAC7BjF,QAAazJ,KAAK8b,KAAK,CACnB/M,OAAQiJ,GAAiB8F,eACzB9O,OAAQ,CAAEH,KAAIH,UACd4K,GACR,CACA,mBAAMyE,CAAclP,GAChBpF,QAAazJ,KAAK8b,KAAK,CACnB/M,OAAQiJ,GAAiBgG,cACzBhP,OAAQ,CAAEH,QACV0K,GACR,EAEJ2B,GAAwB,IAAI+C,QC5I5B,IAWIC,GAXA,GAAkE,SAAU3C,EAAUC,EAAOta,EAAOua,EAAM/Z,GAC1G,GAAa,MAAT+Z,EAAc,MAAM,IAAInZ,UAAU,kCACtC,GAAa,MAATmZ,IAAiB/Z,EAAG,MAAM,IAAIY,UAAU,iDAC5C,GAAqB,mBAAVkZ,EAAuBD,IAAaC,IAAU9Z,GAAK8Z,EAAME,IAAIH,GAAW,MAAM,IAAIjZ,UAAU,2EACvG,MAAiB,MAATmZ,EAAe/Z,EAAE5B,KAAKyb,EAAUra,GAASQ,EAAIA,EAAER,MAAQA,EAAQsa,EAAMpS,IAAImS,EAAUra,GAASA,CACxG,EACI,GAAkE,SAAUqa,EAAUC,EAAOC,EAAM/Z,GACnG,GAAa,MAAT+Z,IAAiB/Z,EAAG,MAAM,IAAIY,UAAU,iDAC5C,GAAqB,mBAAVkZ,EAAuBD,IAAaC,IAAU9Z,GAAK8Z,EAAME,IAAIH,GAAW,MAAM,IAAIjZ,UAAU,4EACvG,MAAgB,MAATmZ,EAAe/Z,EAAa,MAAT+Z,EAAe/Z,EAAE5B,KAAKyb,GAAY7Z,EAAIA,EAAER,MAAQsa,EAAMI,IAAIL,EACxF,EAQIvD,GAAiBsE,cACjBtE,GAAiBmE,WACjBnE,GAAiBkF,cACjBlF,GAAiBoF,cACjBpF,GAAiBsF,cACjBtF,GAAiBiE,aACjBjE,GAAiBgF,oBACjBhF,GAAiB0F,WACjB1F,GAAiB8F,eACjB9F,GAAiBgG,cACjBhG,GAAiBwF,aAMd,MAAMW,GAMT,WAAAtb,CAAYiU,GACRoH,GAA4B9U,IAAIpJ,UAAM,GACtC,GAAuBA,KAAMke,GAA6B,IAAIrC,GAAc/E,GAAS,IACzF,CACA,mBAAMuF,CAAc/T,GAChB,OAAO,GAAuBtI,KAAMke,GAA6B,KAAK7B,cAAc/T,EACxF,CACA,mBAAM6U,CAActO,GAChB,OAAO,GAAuB7O,KAAMke,GAA6B,KAAKf,cAActO,EACxF,CACA,kBAAMmN,GACF,OAAO,GAAuBhc,KAAMke,GAA6B,KAAKlC,cAC1E,CACA,gBAAME,CAAWrN,GACb,OAAO,GAAuB7O,KAAMke,GAA6B,KAAKhC,WAAWrN,EACrF,CACA,gBAAM4O,CAAW5O,GACb,OAAO,GAAuB7O,KAAMke,GAA6B,KAAKT,WAAW5O,EACrF,CACA,kBAAM0O,GACF,OAAO,GAAuBvd,KAAMke,GAA6B,KAAKX,cAC1E,CACA,mBAAMN,CAAclK,GAChB,OAAO,GAAuB/S,KAAMke,GAA6B,KAAKjB,cAAclK,EACxF,CACA,oBAAM8K,CAAehP,EAAIH,GACrB,OAAO,GAAuB1O,KAAMke,GAA6B,KAAKL,eAAehP,EAAIH,EAC7F,CACA,mBAAMqP,CAAclP,GAChB,OAAO,GAAuB7O,KAAMke,GAA6B,KAAKH,cAAclP,EACxF,CACA,yBAAMkO,CAAoBlO,EAAIkK,GAC1B,OAAO,GAAuB/Y,KAAMke,GAA6B,KAAKnB,oBAAoBlO,EAAIkK,EAClG,CACA,mBAAMsE,CAAcxO,GAChB,OAAO,GAAuB7O,KAAMke,GAA6B,KAAKb,cAAcxO,EACxF,EAEJqP,GAA8B,IAAID,QC9ElC,IAWIG,GAAuBC,GAXvB,GAAkE,SAAU9C,EAAUC,EAAOta,EAAOua,EAAM/Z,GAC1G,GAAa,MAAT+Z,EAAc,MAAM,IAAInZ,UAAU,kCACtC,GAAa,MAATmZ,IAAiB/Z,EAAG,MAAM,IAAIY,UAAU,iDAC5C,GAAqB,mBAAVkZ,EAAuBD,IAAaC,IAAU9Z,GAAK8Z,EAAME,IAAIH,GAAW,MAAM,IAAIjZ,UAAU,2EACvG,MAAiB,MAATmZ,EAAe/Z,EAAE5B,KAAKyb,EAAUra,GAASQ,EAAIA,EAAER,MAAQA,EAAQsa,EAAMpS,IAAImS,EAAUra,GAASA,CACxG,EACI,GAAkE,SAAUqa,EAAUC,EAAOC,EAAM/Z,GACnG,GAAa,MAAT+Z,IAAiB/Z,EAAG,MAAM,IAAIY,UAAU,iDAC5C,GAAqB,mBAAVkZ,EAAuBD,IAAaC,IAAU9Z,GAAK8Z,EAAME,IAAIH,GAAW,MAAM,IAAIjZ,UAAU,4EACvG,MAAgB,MAATmZ,EAAe/Z,EAAa,MAAT+Z,EAAe/Z,EAAE5B,KAAKyb,GAAY7Z,EAAIA,EAAER,MAAQsa,EAAMI,IAAIL,EACxF,EAOO,MAAM+C,GAOT,WAAAzb,CAAYmQ,EAAQuL,GAChBH,GAAsBhV,IAAIpJ,UAAM,GAChCqe,GAAwBjV,IAAIpJ,UAAM,GAClC,GAAuBA,KAAMoe,GAAuBpL,EAAQ,KAC5D,GAAuBhT,KAAMqe,GAAyBE,EAAU,IACpE,CAOA,UAAMzC,CAAK7I,GACP,OAAO,GAAuBjT,KAAMqe,GAAyB,KAAKpL,QAAQ,CACtElE,OAAQ,uBACRC,OAAQ,CACJwP,OAAQ,GAAuBxe,KAAMoe,GAAuB,KAC5DnL,YAGZ,EAEJmL,GAAwB,IAAIH,QAAWI,GAA0B,IAAIJ,QAK9D,MAAMQ,WAA6BN,GAOtC,WAAAtb,CAAYmQ,EAAQuL,GAChBnX,MAAM,IAAIkX,GAActL,EAAQuL,GACpC,sGC9BJ,MAAMC,GAASE,GAAAA,EAETC,GAIF,CACFC,gBAAiB,GACjBC,SAAU,GACVC,yBAAyB,GA+V3B,OA5VcC,KACZ,MAAM,EAACvD,EAAK,EAAEwD,IAAYC,EAAAA,GAAAA,YAAWC,GAAAA,KAC/B,EAACC,EAAS,EAAEC,IAAgBC,EAAAA,GAAAA,UAAuBV,KAInD,EAACW,EAAU,EAAEC,IAAiBF,EAAAA,GAAAA,aAC9B,EAACG,EAAS,EAAEC,IAAgBJ,EAAAA,GAAAA,aAC5B,EAACK,EAAa,EAAEC,IAAoBN,EAAAA,GAAAA,aACpC,EAACO,EAAS,EAAEC,IAAgBR,EAAAA,GAAAA,UAAwB,MAGpDS,EAAS,IAAIrB,GAAqBD,GAAQuB,OAAOC,WAEvDC,EAAAA,GAAAA,YAAU,MAMRC,iBACE,IAAK1E,EAAM2E,cACT,OAEF,MAAMtB,QAAiBiB,EAAO9D,eACxB4C,QAAwBkB,EAAOvC,eAC/B6C,QAAsBC,EAAAA,GAAAA,MAC5BjB,EAAa,CACXP,WACAD,kBACAE,wBAAyBsB,GAE7B,EAEAE,GAAWC,OAAO3T,GAAU4T,QAAQ5T,MAAMA,IAAO,GAChD,CAAC4O,EAAM2E,gBAEV,MAAMM,EAAeP,UACnB,MAAMrB,QAAiBiB,EAAO9D,eAC9BoD,EAAa,IACRD,EACHN,YACA,EA8CE6B,GAAsBC,EAAAA,GAAAA,cAAYT,UACtCM,QAAQ/f,IAAI,uCACNmgB,EAAAA,GAAAA,MACNxB,EAAa,IACRD,EACHL,yBAA0BK,EAAUL,yBACpC,GACD,CAACK,IAEE0B,EAA2B,CAC/B,CACExZ,KAAM,iBACNgE,YAAa,uBACbyV,OAAQ,GACRC,OAAQ,CACNC,SAAUd,cA1DMA,WACpB,MAAMe,QAAmBnB,EAAOzD,gBAEhC,aADMoE,IACCQ,CAAU,EAuDe5E,GAC5B6E,MAAO,kBAETC,eAAgB,mBAElB,CACE9Z,KAAM,iBACNgE,YAAa,wCACbyV,OAAQ,CACN,CACEjS,GAAI,6BACJuS,MAAO,cACPlgB,MAAOoe,EACPxZ,KAAMub,GAAAA,EAAUC,UAChBC,YACE,wEACFC,SAAWC,GAAelC,EAAckC,EAAMC,cAAcxgB,SAGhE6f,OAAQ,CACNC,SAAUd,cAxEMA,WACpB,MAAMe,QAAmBnB,EAAOzD,cAAc,CAC5CiD,WAAYA,IAGd,aADMmB,IACCQ,CAAU,EAmEeU,GAC5BT,MAAO,kBAETC,eAAgB,oBAElB,CACE9Z,KAAM,cACNgE,YAAa,mCACbyV,OAAQ,CACN,CACEjS,GAAI,yBACJuS,MAAO,aACPtb,KAAMub,GAAAA,EAAUC,UAChBC,YAAa,4CACbjZ,QAAS6W,EAAUN,SAASle,KAAKoS,IACxB,CAAE7R,MAAO6R,EAAQ1M,YAE1Bmb,SAAWC,GAAehC,EAAagC,EAAMC,cAAcxgB,SAG/D6f,OAAQ,CACNa,SAAUC,QAAQrC,GAClBwB,SAAUd,eAAkBJ,EAAO5D,WAAWsD,GAC9C0B,MAAO,eAETC,eAAgB,mBAElB,CACE9Z,KAAM,gBACNgE,YAAa,sCACb0V,OAAQ,CACNa,UAAU,EACVZ,SAAUd,UACR,MAAMrB,QAAiBiB,EAAO9D,eAK9B,OAJAoD,EAAa,IACRD,EACHN,aAEKA,CAAQ,EAEjBqC,MAAO,kBAGX,CACE7Z,KAAM,iBACNgE,YAAa,oBACbyV,OAAQ,CACN,CACEjS,GAAI,4BACJuS,MAAO,aACPtb,KAAMub,GAAAA,EAAUC,UAChBC,YAAa,4CACbjZ,QAAS6W,EAAUN,SAASle,KAAKoS,IACxB,CAAE7R,MAAO6R,EAAQ1M,YAE1Bmb,SAAWC,GAAehC,EAAagC,EAAMC,cAAcxgB,SAG/D6f,OAAQ,CACNa,SAAUC,QAAQrC,GAClBwB,SAAUd,cA5HMA,iBACdJ,EAAO3C,cAAcqC,SACrBiB,GAAc,EA0HYtD,GAC5B+D,MAAO,kBAETC,eAAgB,mBAElB,CACE9Z,KAAM,iBACNgE,YAAa,oBACbyV,OAAQ,CACN,CACEjS,GAAI,gCACJuS,MAAO,iBACPtb,KAAMub,GAAAA,EAAUS,SAChBP,YAAa,mBACbC,SAAWC,GAAe9B,EAAiB8B,EAAMC,cAAcxgB,SAGnE6f,OAAQ,CACNa,SAAUC,QAAQrC,GAClBwB,SAAUd,cA1IMA,WACpB,IAAKR,EACH,OAEF,MAAM3M,EAA0BxL,KAAK4G,MAAMuR,SACrCI,EAAO7C,cAAclK,SACrB0N,GAAc,EAoIYxD,GAC5BiE,MAAO,kBAETC,eAAgB,oBAIdY,EAAiB,CACrB,CACE1a,KAAM,cACNgE,YAAa,8BACbyV,OAAQ,CACN,CACEjS,GAAI,yBACJuS,MAAO,aACPtb,KAAMub,GAAAA,EAAUC,UAChBC,YAAa,4CACbC,SAAWC,GAAe5B,EAAa4B,EAAMC,cAAcxgB,SAG/D6f,OAAQ,CACNiB,QAASH,QAAQjC,GACjBoB,SAAUd,eAAkBJ,EAAOrC,WAAWmC,GAC9CsB,MAAO,gBAGX,CACE7Z,KAAM,gBACNgE,YAAa,wBACb0V,OAAQ,CACNa,UAAU,EACVZ,SAAUd,UACR,MAAM+B,QAAiBnC,EAAOvC,eAK9B,OAJA6B,EAAa,IACRD,EACHP,gBAAiBqD,IAEZA,CAAQ,EAEjBf,MAAO,kBAGX,CACE7Z,KAAM,kBACNgE,YAAa,kCACbyV,OAAQ,CACN,CACEjS,GAAI,6BACJuS,MAAO,aACPtb,KAAMub,GAAAA,EAAUC,UAChBC,YAAa,4CACbC,SAAWC,IACT5B,EAAa4B,EAAMC,cAAcxgB,MAAM,IAI7C6f,OAAQ,CACNa,UAAWhC,EACXoB,SAAUd,eAAkBJ,EAAOjC,eAAe+B,GAClDsB,MAAO,mBAETC,eAAgB,oBAElB,CACE9Z,KAAM,iBACNgE,YAAa,iCACbyV,OAAQ,CACN,CACEjS,GAAI,4BACJuS,MAAO,aACPtb,KAAMub,GAAAA,EAAUC,UAChBC,YAAa,4CACbC,SAAWC,IACT5B,EAAa4B,EAAMC,cAAcxgB,MAAM,IAI7C6f,OAAQ,CACNa,UAAWhC,EACXoB,SAAUd,eAAkBJ,EAAO/B,cAAc6B,GACjDsB,MAAO,kBAETC,eAAgB,qBAIpB,OACEe,EAAAA,GAAAA,MAACC,GAAAA,GAAS,CAAAC,SAAA,EACRC,EAAAA,GAAAA,KAACC,GAAAA,GAAa,CAAAF,UACV5G,EAAM2E,gBACNkC,EAAAA,GAAAA,KAACE,GAAAA,GAAI,CACHC,QAAS,CACPpB,MAAO,UACP/V,YACE,gEACFoX,QACEJ,EAAAA,GAAAA,KAACK,GAAAA,GAAa,CACZC,QAlOWzC,UACzB,UACQ0C,EAAAA,GAAAA,MACN,MAAMzC,QAAsB0C,EAAAA,GAAAA,MAE5B7D,EAAS,CACPlZ,KAAMgd,GAAAA,GAAgBC,aACtBC,QAAS7C,GAEb,CAAE,MAAOvT,GACP4T,QAAQ5T,MAAMA,GACdoS,EAAS,CAAElZ,KAAMgd,GAAAA,GAAgBG,SAAUD,QAASpW,GACtD,GAuNcgV,UAAWpG,EAAM0H,eAIvBtB,UAAWpG,EAAM0H,iBAKvBb,EAAAA,GAAAA,KAACc,GAAAA,EAAS,CAACC,GAAI,CAAEC,SAAU,GAAIjB,UAC7BF,EAAAA,GAAAA,MAACoB,GAAAA,GAAI,CAACC,WAAS,EAACC,QAAS,EAAGC,QAAS,CAAC,EAAG,EAAG,GAAGrB,SAAA,EAC7CF,EAAAA,GAAAA,MAACoB,GAAAA,GAAI,CAACI,MAAI,EAACC,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAEzB,SAAA,EAC7BC,EAAAA,GAAAA,KAACyB,GAAAA,GAAY,CAAA1B,SAAC,aACdC,EAAAA,GAAAA,KAAC0B,GAAAA,GAAM,CACL3C,MAAM,2BACN4C,eAAgB7E,EAAUL,wBAC1BmF,SAAUvD,EACVsB,QAASH,QAAQrG,EAAM2E,kBAEzBkC,EAAAA,GAAAA,KAAC6B,GAAAA,GAAO,CAAA9B,SAAC,OACTC,EAAAA,GAAAA,KAACyB,GAAAA,GAAY,CAAA1B,SAAC,aACdC,EAAAA,GAAAA,KAAC8B,GAAAA,GAAS,CAACC,MAAOvD,KAClBwB,EAAAA,GAAAA,KAAC6B,GAAAA,GAAO,KACR7B,EAAAA,GAAAA,KAACyB,GAAAA,GAAY,CAAA1B,SAAC,qBACdC,EAAAA,GAAAA,KAAC8B,GAAAA,GAAS,CAACC,MAAOrC,KAClBM,EAAAA,GAAAA,KAAC6B,GAAAA,GAAO,QAEVhC,EAAAA,GAAAA,MAACoB,GAAAA,GAAI,CAACI,MAAI,EAACC,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAEzB,SAAA,EAC7BC,EAAAA,GAAAA,KAAC6B,GAAAA,GAAO,KACR7B,EAAAA,GAAAA,KAACyB,GAAAA,GAAY,CAAA1B,SAAC,cACdC,EAAAA,GAAAA,KAACgC,GAAAA,GAAW,CACVxF,SAAUM,EAAUN,SACpByF,aAAcpE,gBACNJ,EAAO3C,cAAcoH,GAC3B,MAAM1F,QAAiBiB,EAAO9D,eAC9BoD,EAAa,IACRD,EACHN,YACA,cAMF","sources":["webpack://@metamask/snap-simple-keyring-site/../../node_modules/bitcoin-address-validation/lib/index.esm.js","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/superstruct/dist/error.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/superstruct/dist/utils.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/superstruct/dist/struct.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/superstruct/dist/structs/utilities.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-utils/node_modules/@metamask/utils/dist/superstruct.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-utils/dist/types.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/superstruct/dist/structs/types.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-utils/dist/superstruct.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/superstruct/dist/structs/coercions.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/superstruct/dist/structs/refinements.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-utils/node_modules/@metamask/utils/dist/misc.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-utils/node_modules/@metamask/utils/dist/json.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-utils/dist/JsonRpcRequest.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/node_modules/@metamask/utils/dist/misc.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/node_modules/@metamask/utils/dist/json.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/account-options.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/node_modules/@metamask/utils/dist/superstruct.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/node_modules/@metamask/utils/dist/caip-types.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/account.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/asset.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/address.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/balance.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/derivation.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/discovery.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/export.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/request.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/response.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/transaction.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/pagination.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/api/options.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/btc/constants.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/btc/types.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/sol/constants.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/sol/types.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/eth/constants.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/eth/types.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/eth/erc4337/types.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/trx/constants.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/trx/types.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/rpc.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-api/dist/events.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/uuid/dist/esm-browser/native.js","webpack://@metamask/snap-simple-keyring-site/../../node_modules/uuid/dist/esm-browser/rng.js","webpack://@metamask/snap-simple-keyring-site/../../node_modules/uuid/dist/esm-browser/stringify.js","webpack://@metamask/snap-simple-keyring-site/../../node_modules/uuid/dist/esm-browser/v4.js","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-snap-client/dist/KeyringClient.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-snap-client/dist/KeyringPublicClient.mjs","webpack://@metamask/snap-simple-keyring-site/../../node_modules/@metamask/keyring-snap-client/dist/KeyringSnapRpcClient.mjs","webpack://@metamask/snap-simple-keyring-site/./src/pages/index.tsx"],"sourcesContent":["/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar t=function(){return t=Object.assign||function(t){for(var r,e=1,n=arguments.length;e<n;e++)for(var s in r=arguments[e])Object.prototype.hasOwnProperty.call(r,s)&&(t[s]=r[s]);return t},t.apply(this,arguments)};var r=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";var e=t=>{if(!t||\"string\"!=typeof t)throw new Error(`Expected base58 string but got ${t}`);if(t.match(/[IOl0]/gmu))throw new Error(`Invalid base58 character ${t.match(/[IOl0]/gmu)}`);const e=t.match(/^1+/gmu),n=e?e[0].length:0,s=(t.length-n)*(Math.log(58)/Math.log(256))+1>>>0;return new Uint8Array([...new Uint8Array(n),...t.match(/.{1}/gmu).map((t=>r.indexOf(t))).reduce(((t,r)=>t=t.map((t=>{const e=58*t+r;return r=e>>8,e}))),new Uint8Array(s)).reverse().filter((i=!1,t=>i=i||t))]);var i};(()=>{const t=Array(256).fill(-1);for(let e=0;e<r.length;++e)t[r.charCodeAt(e)]=e})();var n=e;var s,i,o,h=(s=function(t,r){Object.defineProperty(r,\"__esModule\",{value:!0}),r.bech32m=r.bech32=void 0;const e=\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\",n={};for(let t=0;t<32;t++){const r=e.charAt(t);n[r]=t}function s(t){const r=t>>25;return(33554431&t)<<5^996825010&-(r>>0&1)^642813549&-(r>>1&1)^513874426&-(r>>2&1)^1027748829&-(r>>3&1)^705979059&-(r>>4&1)}function i(t){let r=1;for(let e=0;e<t.length;++e){const n=t.charCodeAt(e);if(n<33||n>126)return\"Invalid prefix (\"+t+\")\";r=s(r)^n>>5}r=s(r);for(let e=0;e<t.length;++e){const n=t.charCodeAt(e);r=s(r)^31&n}return r}function o(t,r,e,n){let s=0,i=0;const o=(1<<e)-1,h=[];for(let n=0;n<t.length;++n)for(s=s<<r|t[n],i+=r;i>=e;)i-=e,h.push(s>>i&o);if(n)i>0&&h.push(s<<e-i&o);else{if(i>=r)return\"Excess padding\";if(s<<e-i&o)return\"Non-zero padding\"}return h}function h(t){return o(t,8,5,!0)}function c(t){const r=o(t,5,8,!1);if(Array.isArray(r))return r}function a(t){const r=o(t,5,8,!1);if(Array.isArray(r))return r;throw new Error(r)}function f(t){let r;function o(t,e){if(e=e||90,t.length<8)return t+\" too short\";if(t.length>e)return\"Exceeds length limit\";const o=t.toLowerCase(),h=t.toUpperCase();if(t!==o&&t!==h)return\"Mixed-case string \"+t;const c=(t=o).lastIndexOf(\"1\");if(-1===c)return\"No separator character for \"+t;if(0===c)return\"Missing prefix for \"+t;const a=t.slice(0,c),f=t.slice(c+1);if(f.length<6)return\"Data too short\";let u=i(a);if(\"string\"==typeof u)return u;const l=[];for(let t=0;t<f.length;++t){const r=f.charAt(t),e=n[r];if(void 0===e)return\"Unknown character \"+r;u=s(u)^e,t+6>=f.length||l.push(e)}return u!==r?\"Invalid checksum for \"+t:{prefix:a,words:l}}return r=\"bech32\"===t?1:734539939,{decodeUnsafe:function(t,r){const e=o(t,r);if(\"object\"==typeof e)return e},decode:function(t,r){const e=o(t,r);if(\"object\"==typeof e)return e;throw new Error(e)},encode:function(t,n,o){if(o=o||90,t.length+7+n.length>o)throw new TypeError(\"Exceeds length limit\");let h=i(t=t.toLowerCase());if(\"string\"==typeof h)throw new Error(h);let c=t+\"1\";for(let t=0;t<n.length;++t){const r=n[t];if(r>>5!=0)throw new Error(\"Non 5-bit word\");h=s(h)^r,c+=e.charAt(r)}for(let t=0;t<6;++t)h=s(h);h^=r;for(let t=0;t<6;++t)c+=e.charAt(h>>5*(5-t)&31);return c},toWords:h,fromWordsUnsafe:c,fromWords:a}}r.bech32=f(\"bech32\"),r.bech32m=f(\"bech32m\")},s(i={exports:{}},i.exports),i.exports);(o=h)&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,\"default\")&&o.default;var c=h.bech32m,a=h.bech32;const f=[1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998],u={sha256:1};class l{constructor(){this.A=1779033703,this.B=-1150833019,this.C=1013904242,this.D=-1521486534,this.E=1359893119,this.F=-1694144372,this.G=528734635,this.H=1541459225,this._size=0,this._sp=0,(!p||w>=8e3)&&(p=new ArrayBuffer(8e3),w=0),this._byte=new Uint8Array(p,w,80),this._word=new Int32Array(p,w,20),w+=80}update(t){if(\"string\"==typeof t)return this._utf8(t);if(null==t)throw new TypeError(\"Invalid type: \"+typeof t);const r=t.byteOffset,e=t.byteLength;let n=e/64|0,s=0;if(n&&!(3&r)&&!(this._size%64)){const e=new Int32Array(t.buffer,r,16*n);for(;n--;)this._int32(e,s>>2),s+=64;this._size+=s}if(1!==t.BYTES_PER_ELEMENT&&t.buffer){const n=new Uint8Array(t.buffer,r+s,e-s);return this._uint8(n)}return s===e?this:this._uint8(t,s)}_uint8(t,r){const{_byte:e,_word:n}=this,s=t.length;for(r|=0;r<s;){const i=this._size%64;let o=i;for(;r<s&&o<64;)e[o++]=t[r++];o>=64&&this._int32(n),this._size+=o-i}return this}_utf8(t){const{_byte:r,_word:e}=this,n=t.length;let s=this._sp;for(let i=0;i<n;){const o=this._size%64;let h=o;for(;i<n&&h<64;){let e=0|t.charCodeAt(i++);e<128?r[h++]=e:e<2048?(r[h++]=192|e>>>6,r[h++]=128|63&e):e<55296||e>57343?(r[h++]=224|e>>>12,r[h++]=128|e>>>6&63,r[h++]=128|63&e):s?(e=((1023&s)<<10)+(1023&e)+65536,r[h++]=240|e>>>18,r[h++]=128|e>>>12&63,r[h++]=128|e>>>6&63,r[h++]=128|63&e,s=0):s=e}h>=64&&(this._int32(e),e[0]=e[16]),this._size+=h-o}return this._sp=s,this}_int32(t,r){let{A:e,B:n,C:s,D:i,E:o,F:h,G:c,H:a}=this,u=0;for(r|=0;u<16;)d[u++]=g(t[r++]);for(u=16;u<64;u++)d[u]=A(d[u-2])+d[u-7]+m(d[u-15])+d[u-16]|0;for(u=0;u<64;u++){const t=a+E(o)+b(o,h,c)+f[u]+d[u]|0,r=v(e)+_(e,n,s)|0;a=c,c=h,h=o,o=i+t|0,i=s,s=n,n=e,e=t+r|0}this.A=e+this.A|0,this.B=n+this.B|0,this.C=s+this.C|0,this.D=i+this.D|0,this.E=o+this.E|0,this.F=h+this.F|0,this.G=c+this.G|0,this.H=a+this.H|0}digest(t){const{_byte:r,_word:e}=this;let n=this._size%64|0;for(r[n++]=128;3&n;)r[n++]=0;if(n>>=2,n>14){for(;n<16;)e[n++]=0;n=0,this._int32(e)}for(;n<16;)e[n++]=0;const s=8*this._size,i=(4294967295&s)>>>0,o=(s-i)/4294967296;return o&&(e[14]=g(o)),i&&(e[15]=g(i)),this._int32(e),\"hex\"===t?this._hex():this._bin()}_hex(){const{A:t,B:r,C:e,D:n,E:s,F:i,G:o,H:h}=this;return y(t)+y(r)+y(e)+y(n)+y(s)+y(i)+y(o)+y(h)}_bin(){const{A:t,B:r,C:e,D:n,E:s,F:i,G:o,H:h,_byte:c,_word:a}=this;return a[0]=g(t),a[1]=g(r),a[2]=g(e),a[3]=g(n),a[4]=g(s),a[5]=g(i),a[6]=g(o),a[7]=g(h),c.slice(0,32)}}const d=new Int32Array(64);let p,w=0;const y=t=>(t+4294967296).toString(16).substr(-8),g=254===new Uint8Array(new Uint16Array([65279]).buffer)[0]?t=>t:t=>t<<24&4278190080|t<<8&16711680|t>>8&65280|t>>24&255,b=(t,r,e)=>e^t&(r^e),_=(t,r,e)=>t&r|e&(t|r),v=t=>(t>>>2|t<<30)^(t>>>13|t<<19)^(t>>>22|t<<10),E=t=>(t>>>6|t<<26)^(t>>>11|t<<21)^(t>>>25|t<<7),m=t=>(t>>>7|t<<25)^(t>>>18|t<<14)^t>>>3,A=t=>(t>>>17|t<<15)^(t>>>19|t<<13)^t>>>10;var x,k,I=function(t){return function(t){if(t&&!u[t]&&!u[t.toLowerCase()])throw new Error(\"Digest method not supported\");return new l}().update(t).digest()};!function(t){t.mainnet=\"mainnet\",t.testnet=\"testnet\",t.regtest=\"regtest\"}(x||(x={})),function(t){t.p2pkh=\"p2pkh\",t.p2sh=\"p2sh\",t.p2wpkh=\"p2wpkh\",t.p2wsh=\"p2wsh\",t.p2tr=\"p2tr\"}(k||(k={}));var C={0:{type:k.p2pkh,network:x.mainnet},111:{type:k.p2pkh,network:x.testnet},5:{type:k.p2sh,network:x.mainnet},196:{type:k.p2sh,network:x.testnet}},z=function(r){var e,s=r.substr(0,2).toLowerCase();if(\"bc\"===s||\"tb\"===s)return function(t){var r;try{r=t.startsWith(\"bc1p\")||t.startsWith(\"tb1p\")||t.startsWith(\"bcrt1p\")?c.decode(t):a.decode(t)}catch(t){throw new Error(\"Invalid address\")}var e={bc:x.mainnet,tb:x.testnet,bcrt:x.regtest}[r.prefix];if(void 0===e)throw new Error(\"Invalid address\");var n=r.words[0];if(n<0||n>16)throw new Error(\"Invalid address\");return{bech32:!0,network:e,address:t,type:20===a.fromWords(r.words.slice(1)).length?k.p2wpkh:1===n?k.p2tr:k.p2wsh}}(r);try{e=n(r)}catch(t){throw new Error(\"Invalid address\")}var i=e.length;if(25!==i)throw new Error(\"Invalid address\");var o=e[0],h=e.slice(i-4,i),f=e.slice(0,i-4),u=I(I(f)).slice(0,4);if(h.some((function(t,r){return t!==u[r]})))throw new Error(\"Invalid address\");if(!Object.keys(C).map(Number).includes(o))throw new Error(\"Invalid address\");return t(t({},C[o]),{address:r,bech32:!1})},O=function(t,r){try{var e=z(t);return!r||r===e.network}catch(t){return!1}};export{k as AddressType,x as Network,O as default,z as getAddressInfo,O as validate};\n","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nexport class StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const cause = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? cause);\n        if (explanation !== null && explanation !== undefined) {\n            this.cause = cause;\n        }\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n//# sourceMappingURL=error.mjs.map","/**\n * Check if a value is an iterator.\n *\n * @param value - The value to check.\n * @returns Whether the value is an iterator.\n */\nfunction isIterable(value) {\n    return isObject(value) && typeof value[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nexport function isObject(value) {\n    return typeof value === 'object' && value !== null;\n}\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nexport function isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n *\n * @param value - The value to print.\n * @returns The value as a string.\n */\nexport function print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shift (remove and return) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n *\n * @param input - The iterator to shift.\n * @returns The first value of the iterator, or `undefined` if the iterator is\n * empty.\n */\nexport function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @returns A failure if the result is a failure, or `undefined` if the result\n * is a success.\n */\nexport function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return undefined;\n    }\n    else if (result === false) {\n        // eslint-disable-next-line no-param-reassign\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        // eslint-disable-next-line no-param-reassign\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @yields The failures.\n * @returns An iterable of failures.\n */\nexport function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        // eslint-disable-next-line no-param-reassign\n        result = [result];\n    }\n    for (const validationResult of result) {\n        const failure = toFailure(validationResult, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n *\n * @param value - The value to check.\n * @param struct - The struct to check against.\n * @param options - Optional settings.\n * @param options.path - The path to the value in the input data.\n * @param options.branch - The branch of the value in the input data.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @yields An iterator of failures or success.\n * @returns An iterator of failures or success.\n */\nexport function* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const context = { path, branch };\n    if (coerce) {\n        // eslint-disable-next-line no-param-reassign\n        value = struct.coercer(value, context);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, context)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    // eslint-disable-next-line prefer-const\n    for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)) {\n        const iterable = run(innerValue, innerStruct, {\n            path: innerKey === undefined ? path : [...path, innerKey],\n            branch: innerKey === undefined ? branch : [...branch, innerValue],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const result of iterable) {\n            if (result[0]) {\n                status =\n                    result[0].refinement === null || result[0].refinement === undefined\n                        ? 'not_valid'\n                        : 'not_refined';\n                yield [result[0], undefined];\n            }\n            else if (coerce) {\n                innerValue = result[1];\n                if (innerKey === undefined) {\n                    // eslint-disable-next-line no-param-reassign\n                    value = innerValue;\n                }\n                else if (value instanceof Map) {\n                    value.set(innerKey, innerValue);\n                }\n                else if (value instanceof Set) {\n                    value.add(innerValue);\n                }\n                else if (isObject(value)) {\n                    if (innerValue !== undefined || innerKey in value) {\n                        value[innerKey] = innerValue;\n                    }\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, context)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n//# sourceMappingURL=utils.mjs.map","import { StructError } from \"./error.mjs\";\nimport { toFailures, shiftIterator, run } from \"./utils.mjs\";\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nexport class Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () {\n            /* noop */\n        }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n */\nexport function assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n *\n * @param value - The value to coerce and validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n * @returns The coerced and validated value.\n */\nexport function create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n *\n * @param value - The value to mask.\n * @param struct - The struct to mask against.\n * @param message - An optional message to include in the error.\n * @returns The masked value.\n */\nexport function mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @returns `true` if the value passes the struct, `false` otherwise.\n */\nexport function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param options - Optional settings.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @returns A tuple containing the error (if invalid) and the validated value.\n */\nexport function validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const innerTuple of tuples) {\n                if (innerTuple[0]) {\n                    yield innerTuple[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    const validatedValue = tuple[1];\n    return [undefined, validatedValue];\n}\n//# sourceMappingURL=struct.mjs.map","import { Struct } from \"../struct.mjs\";\nimport { object, optional, type } from \"./types.mjs\";\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param Structs - The structs to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign(...Structs) {\n    const isType = Structs[0]?.type === 'type';\n    const schemas = Structs.map(({ schema }) => schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @param name - The name of the struct type.\n * @param validator - The validation function.\n * @returns A new struct type.\n */\nexport function define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n *\n * @param struct - The struct to augment.\n * @param log - The function to call when the value is not `undefined`.\n * @returns A new struct that will only accept `undefined` or values that pass\n * the input struct.\n */\nexport function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            log(value, ctx);\n            return struct.validator(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with dynamic validation logic.\n */\nexport function dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with lazily evaluated validation logic.\n */\nexport function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to omit.\n * @returns A new struct that will not accept the input keys.\n */\nexport function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept the input keys as `undefined`.\n */\nexport function partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    // eslint-disable-next-line guard-for-in\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to pick.\n * @returns A new struct that will only accept the input keys.\n */\nexport function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n//# sourceMappingURL=utilities.mjs.map","import { define } from \"@metamask/superstruct\";\n/**\n * Defines a new string-struct matching a regular expression.\n *\n * @example\n * const EthAddressStruct = definePattern('EthAddress', /^0x[0-9a-f]{40}$/iu);\n * type EthAddress = Infer<typeof EthAddressStruct>; // string\n *\n * const CaipChainIdStruct = defineTypedPattern<`${string}:${string}`>(\n *   'CaipChainId',\n *   /^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/u;\n * );\n * type CaipChainId = Infer<typeof CaipChainIdStruct>; // `${string}:${string}`\n * @param name - Type name.\n * @param pattern - Regular expression to match.\n * @template Pattern - The pattern type, defaults to `string`.\n * @returns A new string-struct that matches the given pattern.\n */\nexport function definePattern(name, pattern) {\n    return define(name, (value) => {\n        return typeof value === 'string' && pattern.test(value);\n    });\n}\n//# sourceMappingURL=superstruct.mjs.map","import { define } from \"@metamask/superstruct\";\nimport { definePattern } from \"@metamask/utils\";\n/**\n * UUIDv4 struct.\n */\nexport const UuidStruct = definePattern('UuidV4', /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/iu);\n/**\n * Account ID (UUIDv4).\n */\nexport const AccountIdStruct = UuidStruct; // Alias for better naming purposes.\n/**\n * Validates if a given value is a valid URL.\n *\n * @param value - The value to be validated.\n * @returns A boolean indicating if the value is a valid URL.\n */\nexport const UrlStruct = define('Url', (value) => {\n    try {\n        const url = new URL(value);\n        return url.protocol === 'http:' || url.protocol === 'https:';\n    }\n    catch {\n        return false;\n    }\n});\n/**\n * A string which contains a positive float number.\n */\nexport const StringNumberStruct = definePattern('StringNumber', /^\\d+(\\.\\d+)?$/u);\n//# sourceMappingURL=types.mjs.map","import { Struct } from \"../struct.mjs\";\nimport { print, run, isObject } from \"../utils.mjs\";\nimport { define } from \"./utilities.mjs\";\n/**\n * Ensure that any value passes validation.\n *\n * @returns A struct that will always pass validation.\n */\nexport function any() {\n    return define('any', () => true);\n}\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nexport function array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [index, arrayValue] of value.entries()) {\n                    yield [index, arrayValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n *\n * @returns A new struct that will only accept bigints.\n */\nexport function bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n *\n * @returns A new struct that will only accept booleans.\n */\nexport function boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n *\n * @returns A new struct that will only accept valid `Date` objects.\n */\nexport function date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums(values) {\n    const schema = {};\n    const description = values.map((value) => print(value)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n *\n * @returns A new struct that will only accept functions.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n *\n * @param Class - The class that the value must be an instance of.\n * @returns A new struct that will only accept instances of the given class.\n */\nexport function instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n *\n * @returns A new struct that will only accept integers.\n */\nexport function integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match all of the\n * given structs.\n */\nexport function intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, context) {\n            for (const { entries } of Structs) {\n                yield* entries(value, context);\n            }\n        },\n        *validator(value, context) {\n            for (const { validator } of Structs) {\n                yield* validator(value, context);\n            }\n        },\n        *refiner(value, context) {\n            for (const { refiner } of Structs) {\n                yield* refiner(value, context);\n            }\n        },\n    });\n}\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal(constant) {\n    const description = print(constant);\n    const valueType = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: valueType === 'string' ||\n            valueType === 'number' ||\n            valueType === 'boolean'\n            ? constant\n            : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [mapKey, mapValue] of value.entries()) {\n                    yield [mapKey, mapKey, Key];\n                    yield [mapKey, mapValue, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n *\n * @returns A new struct that will never pass validation.\n */\nexport function never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `null` values.\n */\nexport function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n *\n * @returns A new struct that will only accept numbers.\n */\nexport function number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ?? null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `undefined` values.\n */\nexport function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * @param Key - The struct to validate each key in the record against.\n * @param Value - The struct to validate each value in the record against.\n * @returns A new struct that will only accept objects.\n */\nexport function record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                // eslint-disable-next-line guard-for-in\n                for (const objectKey in value) {\n                    const objectValue = value[objectKey];\n                    yield [objectKey, objectKey, Key];\n                    yield [objectKey, objectValue, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n *\n * @returns A new struct that will only accept `RegExp` objects.\n */\nexport function regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const setValue of value) {\n                    yield [setValue, setValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n *\n * @returns A new struct that will only accept strings.\n */\nexport function string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept tuples of the given types.\n */\nexport function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match one of the\n * given structs.\n */\nexport function union(Structs) {\n    const description = Structs.map((struct) => struct.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const InnerStruct of Structs) {\n                const [error, coerced] = InnerStruct.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const InnerStruct of Structs) {\n                const [...tuples] = run(value, InnerStruct, ctx);\n                const [first] = tuples;\n                if (!first?.[0]) {\n                    return [];\n                }\n                for (const [failure] of tuples) {\n                    if (failure) {\n                        failures.push(failure);\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n *\n * @returns A struct that will always pass validation.\n */\nexport function unknown() {\n    return define('unknown', () => true);\n}\n//# sourceMappingURL=types.mjs.map","import { Struct, assert, object as stObject, type as stType } from \"@metamask/superstruct\";\n/**\n * Change the return type of a superstruct's `object` function to support\n * exact optional properties.\n *\n * @param schema - The object schema.\n * @returns A struct representing an object with a known set of properties.\n */\nexport function object(schema) {\n    return stObject(schema);\n}\n/**\n * Change the return type of a superstruct's `type` function to support\n * exact optional properties.\n *\n * @param schema - The object schema.\n * @returns A struct representing an object with a known set of properties\n * and ignore unknown properties.\n */\nexport function type(schema) {\n    return stType(schema);\n}\n/**\n * Check if the current property is present in its parent object.\n *\n * @param ctx - The context to check.\n * @returns `true` if the property is present, `false` otherwise.\n */\nfunction hasOptional(ctx) {\n    const property = ctx.path[ctx.path.length - 1];\n    const parent = ctx.branch[ctx.branch.length - 2];\n    return property in parent;\n}\n/**\n * Augment a struct to allow exact-optional values. Exact-optional values can\n * be omitted but cannot be `undefined`.\n *\n * ```ts\n * const foo = object({ bar: exactOptional(string()) });\n * type Foo = Infer<typeof foo>;\n * // Foo = { bar?: string }\n * ```\n *\n * @param struct - The struct to augment.\n * @returns The augmented struct.\n */\nexport function exactOptional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => !hasOptional(ctx) || struct.validator(value, ctx),\n        refiner: (value, ctx) => !hasOptional(ctx) || struct.refiner(value, ctx),\n    });\n}\n/**\n * Assert that a value is valid according to a struct.\n *\n * It is similar to superstruct's mask function, but it does not ignore extra\n * properties.\n *\n * @param value - Value to check.\n * @param struct - Struct to validate the value against.\n * @param message - Error message to throw if the value is not valid.\n * @returns The value if it is valid.\n */\nexport function strictMask(value, struct, message) {\n    assert(value, struct, message);\n    return value;\n}\n/**\n * Create a custom union struct that uses a `selector` function for choosing\n * the validation path.\n *\n * @param selector - The selector function choosing the struct to validate with.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function selectiveUnion(selector) {\n    return new Struct({\n        type: 'union',\n        schema: null,\n        *entries(value, context) {\n            yield* selector(value).entries(value, context);\n        },\n        *refiner(value, context) {\n            yield* selector(value).refiner(value, context);\n        },\n        coercer(value, context) {\n            return selector(value).coercer(value, context);\n        },\n        validator(value, context) {\n            // This only validates the root of the struct, entries does the rest of\n            // the work.\n            return selector(value).validator(value, context);\n        },\n    });\n}\n//# sourceMappingURL=superstruct.mjs.map","import { Struct, is } from \"../struct.mjs\";\nimport { isPlainObject } from \"../utils.mjs\";\nimport { string, unknown } from \"./types.mjs\";\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param condition - A struct that the input must pass to be coerced.\n * @param coercer - A function that takes the input and returns the coerced\n * value.\n * @returns A new struct that will coerce its input before validating it.\n */\nexport function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param fallback - The value to use when the input is `undefined`.\n * @param options - An optional options object.\n * @param options.strict - When `true`, the fallback will only be used when the\n * input is `undefined`. When `false`, the fallback will be used when the input\n * is `undefined` or when the input is a plain object and the fallback is a\n * plain object, and any keys in the fallback are missing from the input.\n * @returns A new struct that will replace `undefined` inputs with a default.\n */\nexport function defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (value) => {\n        const result = typeof fallback === 'function' ? fallback() : fallback;\n        if (value === undefined) {\n            return result;\n        }\n        if (!options.strict && isPlainObject(value) && isPlainObject(result)) {\n            const ret = { ...value };\n            let changed = false;\n            for (const key in result) {\n                if (ret[key] === undefined) {\n                    ret[key] = result[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return value;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will trim string inputs before validating them.\n */\nexport function trimmed(struct) {\n    return coerce(struct, string(), (value) => value.trim());\n}\n//# sourceMappingURL=coercions.mjs.map","import { Struct } from \"../struct.mjs\";\nimport { toFailures } from \"../utils.mjs\";\n/**\n * Ensure that a string, array, map, or set is empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept empty values.\n */\nexport function empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\n/**\n * Get the size of a string, array, map, or set.\n *\n * @param value - The value to measure.\n * @returns The size of the value.\n */\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    return value.length;\n}\n/**\n * Ensure that a number or date is below a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The maximum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly less than\n * the threshold. When `false`, the input must be less than or equal to the\n * threshold.\n * @returns A new struct that will only accept values below the threshold.\n */\nexport function max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The minimum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly greater\n * than the threshold. When `false`, the input must be greater than or equal to\n * the threshold.\n * @returns A new struct that will only accept values above the threshold.\n */\nexport function min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept non-empty values.\n */\nexport function nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n *\n * @param struct - The struct to augment.\n * @param regexp - The regular expression to match against.\n * @returns A new struct that will only accept strings matching the regular\n * expression.\n */\nexport function pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length,\n * or time) between `min` and `max`.\n *\n * @param struct - The struct to augment.\n * @param minimum - The minimum size that the input can be.\n * @param maximum - The maximum size that the input can be.\n * @returns A new struct that will only accept values within the given size\n * range.\n */\nexport function size(struct, minimum, maximum = minimum) {\n    const expected = `Expected a ${struct.type}`;\n    const of = minimum === maximum\n        ? `of \\`${minimum}\\``\n        : `between \\`${minimum}\\` and \\`${maximum}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((minimum <= value && value <= maximum) ||\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            // eslint-disable-next-line @typescript-eslint/no-shadow\n            const { size } = value;\n            return ((minimum <= size && size <= maximum) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        const { length } = value;\n        return ((minimum <= length && length <= maximum) ||\n            `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n *\n * @param struct - The struct to augment.\n * @param name - The name of the refinement.\n * @param refiner - The refiner function.\n * @returns A new struct that will run the refiner function after the existing\n * validation.\n */\nexport function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n//# sourceMappingURL=refinements.mjs.map","//\n// Types\n//\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nexport function isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nexport function isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nexport function isObject(value) {\n    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nexport const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nexport function getKnownPropertyNames(object) {\n    return Object.getOwnPropertyNames(object);\n}\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nexport var JsonSize;\n(function (JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = JsonSize || (JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexport const ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nexport function isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while (Object.getPrototypeOf(proto) !== null) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    }\n    catch (_) {\n        return false;\n    }\n}\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nexport function isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nexport function calculateStringSize(value) {\n    const size = value.split('').reduce((total, character) => {\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nexport function calculateNumberSize(value) {\n    return value.toString().length;\n}\n//# sourceMappingURL=misc.mjs.map","import { any, array, coerce, create, define, integer, is, literal, nullable, number, object as superstructObject, optional, record, string, union, unknown, Struct, refine } from \"@metamask/superstruct\";\nimport { assertStruct } from \"./assert.mjs\";\nimport { hasProperty } from \"./misc.mjs\";\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nexport const object = (schema) => \n// The type is slightly different from a regular object struct, because we\n// want to make properties with `undefined` in their type optional, but not\n// `undefined` itself. This means that we need a type cast.\nsuperstructObject(schema);\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }) {\n    const field = path[path.length - 1];\n    return hasProperty(branch[branch.length - 2], field);\n}\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nexport function exactOptional(struct) {\n    return new Struct({\n        ...struct,\n        type: `optional ${struct.type}`,\n        validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n        refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context),\n    });\n}\n/**\n * Validate an unknown input to be valid JSON.\n *\n * Useful for constructing JSON structs.\n *\n * @param json - An unknown value.\n * @returns True if the value is valid JSON, otherwise false.\n */\nfunction validateJson(json) {\n    if (json === null || typeof json === 'boolean' || typeof json === 'string') {\n        return true;\n    }\n    if (typeof json === 'number' && Number.isFinite(json)) {\n        return true;\n    }\n    if (typeof json === 'object') {\n        let every = true;\n        if (Array.isArray(json)) {\n            // Ignoring linting error since for-of is significantly slower than a normal for-loop\n            // and performance is important in this specific function.\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\n            for (let i = 0; i < json.length; i++) {\n                if (!validateJson(json[i])) {\n                    every = false;\n                    break;\n                }\n            }\n            return every;\n        }\n        const entries = Object.entries(json);\n        // Ignoring linting errors since for-of is significantly slower than a normal for-loop\n        // and performance is important in this specific function.\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < entries.length; i++) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (typeof entries[i][0] !== 'string' || !validateJson(entries[i][1])) {\n                every = false;\n                break;\n            }\n        }\n        return every;\n    }\n    return false;\n}\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\nexport const UnsafeJsonStruct = define('JSON', (json) => validateJson(json));\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexport const JsonStruct = coerce(UnsafeJsonStruct, refine(any(), 'JSON', (value) => is(value, UnsafeJsonStruct)), (value) => JSON.parse(JSON.stringify(value, (propKey, propValue) => {\n    // Strip __proto__ and constructor properties to prevent prototype pollution.\n    if (propKey === '__proto__' || propKey === 'constructor') {\n        return undefined;\n    }\n    return propValue;\n})));\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nexport function isValidJson(value) {\n    try {\n        getSafeJson(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nexport function getSafeJson(value) {\n    return create(value, JsonStruct);\n}\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nexport function getJsonSize(value) {\n    assertStruct(value, JsonStruct, 'Invalid JSON value');\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\n/**\n * The string '2.0'.\n */\nexport const jsonrpc2 = '2.0';\nexport const JsonRpcVersionStruct = literal(jsonrpc2);\nexport const JsonRpcIdStruct = nullable(union([number(), string()]));\nexport const JsonRpcErrorStruct = object({\n    code: integer(),\n    message: string(),\n    data: exactOptional(JsonStruct),\n    stack: exactOptional(string()),\n});\nexport const JsonRpcParamsStruct = union([record(string(), JsonStruct), array(JsonStruct)]);\nexport const JsonRpcRequestStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    method: string(),\n    params: exactOptional(JsonRpcParamsStruct),\n});\nexport const JsonRpcNotificationStruct = object({\n    jsonrpc: JsonRpcVersionStruct,\n    method: string(),\n    params: exactOptional(JsonRpcParamsStruct),\n});\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nexport function isJsonRpcNotification(value) {\n    return is(value, JsonRpcNotificationStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nexport function assertIsJsonRpcNotification(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nexport function isJsonRpcRequest(value) {\n    return is(value, JsonRpcRequestStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nexport function assertIsJsonRpcRequest(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);\n}\nexport const PendingJsonRpcResponseStruct = superstructObject({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: optional(unknown()),\n    error: optional(JsonRpcErrorStruct),\n});\nexport const JsonRpcSuccessStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: JsonStruct,\n});\nexport const JsonRpcFailureStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    error: JsonRpcErrorStruct,\n});\nexport const JsonRpcResponseStruct = union([\n    JsonRpcSuccessStruct,\n    JsonRpcFailureStruct,\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nexport function isPendingJsonRpcResponse(response) {\n    return is(response, PendingJsonRpcResponseStruct);\n}\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nexport function assertIsPendingJsonRpcResponse(response, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(response, PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);\n}\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nexport function isJsonRpcResponse(response) {\n    return is(response, JsonRpcResponseStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nexport function assertIsJsonRpcResponse(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nexport function isJsonRpcSuccess(value) {\n    return is(value, JsonRpcSuccessStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nexport function assertIsJsonRpcSuccess(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nexport function isJsonRpcFailure(value) {\n    return is(value, JsonRpcFailureStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nexport function assertIsJsonRpcFailure(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nexport function isJsonRpcError(value) {\n    return is(value, JsonRpcErrorStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nexport function assertIsJsonRpcError(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);\n}\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nexport function getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = {\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true,\n        ...options,\n    };\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */\n    const isValidJsonRpcId = (id) => {\n        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n            (permitNull && id === null));\n    };\n    return isValidJsonRpcId;\n}\n//# sourceMappingURL=json.mjs.map","import { array, literal, number, record, string, union } from \"@metamask/superstruct\";\nimport { JsonStruct } from \"@metamask/utils\";\nimport { exactOptional, object } from \"./index.mjs\";\nexport const JsonRpcRequestStruct = object({\n    jsonrpc: literal('2.0'),\n    id: union([string(), number(), literal(null)]),\n    method: string(),\n    params: exactOptional(union([array(JsonStruct), record(string(), JsonStruct)])),\n});\n//# sourceMappingURL=JsonRpcRequest.mjs.map","//\n// Types\n//\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nexport function isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nexport function isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nexport function isObject(value) {\n    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nexport const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nexport function getKnownPropertyNames(object) {\n    return Object.getOwnPropertyNames(object);\n}\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nexport var JsonSize;\n(function (JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = JsonSize || (JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexport const ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nexport function isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while (Object.getPrototypeOf(proto) !== null) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    }\n    catch (_) {\n        return false;\n    }\n}\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nexport function isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nexport function calculateStringSize(value) {\n    const size = value.split('').reduce((total, character) => {\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nexport function calculateNumberSize(value) {\n    return value.toString().length;\n}\n//# sourceMappingURL=misc.mjs.map","import { any, array, coerce, create, define, integer, is, literal, nullable, number, object as superstructObject, optional, record, string, union, unknown, Struct, refine } from \"@metamask/superstruct\";\nimport { assertStruct } from \"./assert.mjs\";\nimport { hasProperty } from \"./misc.mjs\";\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nexport const object = (schema) => \n// The type is slightly different from a regular object struct, because we\n// want to make properties with `undefined` in their type optional, but not\n// `undefined` itself. This means that we need a type cast.\nsuperstructObject(schema);\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }) {\n    const field = path[path.length - 1];\n    return hasProperty(branch[branch.length - 2], field);\n}\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nexport function exactOptional(struct) {\n    return new Struct({\n        ...struct,\n        type: `optional ${struct.type}`,\n        validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n        refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context),\n    });\n}\n/**\n * Validate an unknown input to be valid JSON.\n *\n * Useful for constructing JSON structs.\n *\n * @param json - An unknown value.\n * @returns True if the value is valid JSON, otherwise false.\n */\nfunction validateJson(json) {\n    if (json === null || typeof json === 'boolean' || typeof json === 'string') {\n        return true;\n    }\n    if (typeof json === 'number' && Number.isFinite(json)) {\n        return true;\n    }\n    if (typeof json === 'object') {\n        let every = true;\n        if (Array.isArray(json)) {\n            // Ignoring linting error since for-of is significantly slower than a normal for-loop\n            // and performance is important in this specific function.\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\n            for (let i = 0; i < json.length; i++) {\n                if (!validateJson(json[i])) {\n                    every = false;\n                    break;\n                }\n            }\n            return every;\n        }\n        const entries = Object.entries(json);\n        // Ignoring linting errors since for-of is significantly slower than a normal for-loop\n        // and performance is important in this specific function.\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < entries.length; i++) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (typeof entries[i][0] !== 'string' || !validateJson(entries[i][1])) {\n                every = false;\n                break;\n            }\n        }\n        return every;\n    }\n    return false;\n}\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\nexport const UnsafeJsonStruct = define('JSON', (json) => validateJson(json));\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexport const JsonStruct = coerce(UnsafeJsonStruct, refine(any(), 'JSON', (value) => is(value, UnsafeJsonStruct)), (value) => JSON.parse(JSON.stringify(value, (propKey, propValue) => {\n    // Strip __proto__ and constructor properties to prevent prototype pollution.\n    if (propKey === '__proto__' || propKey === 'constructor') {\n        return undefined;\n    }\n    return propValue;\n})));\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nexport function isValidJson(value) {\n    try {\n        getSafeJson(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nexport function getSafeJson(value) {\n    return create(value, JsonStruct);\n}\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nexport function getJsonSize(value) {\n    assertStruct(value, JsonStruct, 'Invalid JSON value');\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\n/**\n * The string '2.0'.\n */\nexport const jsonrpc2 = '2.0';\nexport const JsonRpcVersionStruct = literal(jsonrpc2);\nexport const JsonRpcIdStruct = nullable(union([number(), string()]));\nexport const JsonRpcErrorStruct = object({\n    code: integer(),\n    message: string(),\n    data: exactOptional(JsonStruct),\n    stack: exactOptional(string()),\n});\nexport const JsonRpcParamsStruct = union([record(string(), JsonStruct), array(JsonStruct)]);\nexport const JsonRpcRequestStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    method: string(),\n    params: exactOptional(JsonRpcParamsStruct),\n});\nexport const JsonRpcNotificationStruct = object({\n    jsonrpc: JsonRpcVersionStruct,\n    method: string(),\n    params: exactOptional(JsonRpcParamsStruct),\n});\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nexport function isJsonRpcNotification(value) {\n    return is(value, JsonRpcNotificationStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nexport function assertIsJsonRpcNotification(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nexport function isJsonRpcRequest(value) {\n    return is(value, JsonRpcRequestStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nexport function assertIsJsonRpcRequest(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);\n}\nexport const PendingJsonRpcResponseStruct = superstructObject({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: optional(unknown()),\n    error: optional(JsonRpcErrorStruct),\n});\nexport const JsonRpcSuccessStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: JsonStruct,\n});\nexport const JsonRpcFailureStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    error: JsonRpcErrorStruct,\n});\nexport const JsonRpcResponseStruct = union([\n    JsonRpcSuccessStruct,\n    JsonRpcFailureStruct,\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nexport function isPendingJsonRpcResponse(response) {\n    return is(response, PendingJsonRpcResponseStruct);\n}\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nexport function assertIsPendingJsonRpcResponse(response, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(response, PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);\n}\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nexport function isJsonRpcResponse(response) {\n    return is(response, JsonRpcResponseStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nexport function assertIsJsonRpcResponse(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nexport function isJsonRpcSuccess(value) {\n    return is(value, JsonRpcSuccessStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nexport function assertIsJsonRpcSuccess(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nexport function isJsonRpcFailure(value) {\n    return is(value, JsonRpcFailureStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nexport function assertIsJsonRpcFailure(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nexport function isJsonRpcError(value) {\n    return is(value, JsonRpcErrorStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nexport function assertIsJsonRpcError(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);\n}\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nexport function getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = {\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true,\n        ...options,\n    };\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */\n    const isValidJsonRpcId = (id) => {\n        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n            (permitNull && id === null));\n    };\n    return isValidJsonRpcId;\n}\n//# sourceMappingURL=json.mjs.map","import { exactOptional, selectiveUnion, type } from \"@metamask/keyring-utils\";\nimport { boolean, intersection, literal, number, object, record, string } from \"@metamask/superstruct\";\nimport { isPlainObject, JsonStruct } from \"@metamask/utils\";\n/**\n * Keyring account entropy valid types.\n */\nexport var KeyringAccountEntropyTypeOption;\n(function (KeyringAccountEntropyTypeOption) {\n    /**\n     * Indicates that the account was created from a mnemonic phrase.\n     */\n    KeyringAccountEntropyTypeOption[\"Mnemonic\"] = \"mnemonic\";\n    /**\n     * Indicates that the account was imported from a private key.\n     */\n    KeyringAccountEntropyTypeOption[\"PrivateKey\"] = \"private-key\";\n})(KeyringAccountEntropyTypeOption || (KeyringAccountEntropyTypeOption = {}));\n/**\n * Keyring account options struct for mnemonics (BIP-44).\n */\nexport const KeyringAccountEntropyMnemonicOptionsStruct = object({\n    /**\n     * Indicates that the account was created from a mnemonic phrase.\n     */\n    type: literal(`${KeyringAccountEntropyTypeOption.Mnemonic}`),\n    /**\n     * The ID of the entropy source.\n     */\n    id: string(), // TODO: Define a struct for entropy source.\n    /**\n     * The BIP-44 derivation path used to derive the account.\n     */\n    derivationPath: string(),\n    /**\n     * Index used to group accounts in the UI.\n     *\n     * Accounts sharing the same `groupIndex` are displayed together as a\n     * multichain account group.\n     */\n    groupIndex: number(),\n});\n/**\n * Keyring account options struct for private keys.\n */\nexport const KeyringAccountEntropyPrivateKeyOptionsStruct = object({\n    /**\n     * Indicates that the account was imported from a private key.\n     */\n    type: literal(`${KeyringAccountEntropyTypeOption.PrivateKey}`),\n});\n/**\n * Keyring account entropy options struct.\n */\nexport const KeyringAccountEntropyOptionsStruct = selectiveUnion((value) => {\n    return isPlainObject(value) &&\n        value.type === KeyringAccountEntropyTypeOption.PrivateKey\n        ? KeyringAccountEntropyPrivateKeyOptionsStruct\n        : KeyringAccountEntropyMnemonicOptionsStruct;\n});\n/**\n * Keyring options struct. This represents various options for a Keyring account object.\n *\n * See {@link KeyringAccountEntropyMnemonicOptionsStruct} and\n * {@link KeyringAccountEntropyPrivateKeyOptionsStruct}.\n *\n * @example\n * ```ts\n * {\n *   entropy: {\n *     type: 'mnemonic',\n *     id: '01K0BX6VDR5DPDPGGNA8PZVBVB',\n *     derivationPath: \"m/44'/60'/0'/0/0\",\n *     groupIndex: 0,\n *   },\n * }\n * ```\n *\n * @example\n * ```ts\n * {\n *   entropy: {\n *     type: 'private-key',\n *   },\n *   exportable: true,\n * }\n * ```\n *\n * @example\n * ```ts\n * {\n *   some: {\n *     untyped: 'options',\n *     something: true,\n *   },\n * }\n * ```\n */\nexport const KeyringAccountOptionsStruct = intersection([\n    // Non-Typed options (retro-compatibility):\n    record(string(), JsonStruct),\n    // Typed options. We use `type` instead of `object` here, to allow\n    // extra properties. Also, since we use `record` + `intersection` we\n    // are guaranteed that all field values will match the `JsonStruct`.\n    //\n    // READ THIS CAREFULLY:\n    // Previous options that can be matched by this struct will be breaking\n    // existing keyring account options.\n    type({\n        /**\n         * Entropy options.\n         */\n        entropy: exactOptional(KeyringAccountEntropyOptionsStruct),\n        /**\n         * Indicates whether the account can be exported.\n         */\n        exportable: exactOptional(boolean()),\n    }),\n]);\n//# sourceMappingURL=account-options.mjs.map","import { define } from \"@metamask/superstruct\";\n/**\n * Defines a new string-struct matching a regular expression.\n *\n * @example\n * const EthAddressStruct = definePattern('EthAddress', /^0x[0-9a-f]{40}$/iu);\n * type EthAddress = Infer<typeof EthAddressStruct>; // string\n *\n * const CaipChainIdStruct = defineTypedPattern<`${string}:${string}`>(\n *   'CaipChainId',\n *   /^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/u;\n * );\n * type CaipChainId = Infer<typeof CaipChainIdStruct>; // `${string}:${string}`\n * @param name - Type name.\n * @param pattern - Regular expression to match.\n * @template Pattern - The pattern type, defaults to `string`.\n * @returns A new string-struct that matches the given pattern.\n */\nexport function definePattern(name, pattern) {\n    return define(name, (value) => {\n        return typeof value === 'string' && pattern.test(value);\n    });\n}\n//# sourceMappingURL=superstruct.mjs.map","import { is } from \"@metamask/superstruct\";\nimport { definePattern } from \"./superstruct.mjs\";\nexport const CAIP_CHAIN_ID_REGEX = /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u;\nexport const CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\nexport const CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u;\nexport const CAIP_ACCOUNT_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u;\nexport const CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\nexport const CAIP_ASSET_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\nexport const CAIP_ASSET_REFERENCE_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\nexport const CAIP_TOKEN_ID_REGEX = /^[-.%a-zA-Z0-9]{1,78}$/u;\nexport const CAIP_ASSET_TYPE_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})$/u;\nexport const CAIP_ASSET_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})\\/(?<tokenId>[-.%a-zA-Z0-9]{1,78})$/u;\nconst CAIP_ASSET_TYPE_OR_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})(\\/(?<tokenId>[-.%a-zA-Z0-9]{1,78}))?$/u;\n/**\n * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.\n */\nexport const CaipChainIdStruct = definePattern('CaipChainId', CAIP_CHAIN_ID_REGEX);\n/**\n * A CAIP-2 namespace, i.e., the first part of a CAIP chain ID.\n */\nexport const CaipNamespaceStruct = definePattern('CaipNamespace', CAIP_NAMESPACE_REGEX);\n/**\n * A CAIP-2 reference, i.e., the second part of a CAIP chain ID.\n */\nexport const CaipReferenceStruct = definePattern('CaipReference', CAIP_REFERENCE_REGEX);\n/**\n * A CAIP-10 account ID, i.e., a human-readable namespace, reference, and account address.\n */\nexport const CaipAccountIdStruct = definePattern('CaipAccountId', CAIP_ACCOUNT_ID_REGEX);\n/**\n * A CAIP-10 account address, i.e., the third part of the CAIP account ID.\n */\nexport const CaipAccountAddressStruct = definePattern('CaipAccountAddress', CAIP_ACCOUNT_ADDRESS_REGEX);\n/**\n * A CAIP-19 asset namespace, i.e., a namespace domain of an asset.\n */\nexport const CaipAssetNamespaceStruct = definePattern('CaipAssetNamespace', CAIP_ASSET_NAMESPACE_REGEX);\n/**\n * A CAIP-19 asset reference, i.e., an identifier for an asset within a given namespace.\n */\nexport const CaipAssetReferenceStruct = definePattern('CaipAssetReference', CAIP_ASSET_REFERENCE_REGEX);\n/**\n * A CAIP-19 asset token ID, i.e., a unique identifier for an addressable asset of a given type\n */\nexport const CaipTokenIdStruct = definePattern('CaipTokenId', CAIP_TOKEN_ID_REGEX);\n/**\n * A CAIP-19 asset type identifier, i.e., a human-readable type of asset identifier.\n */\nexport const CaipAssetTypeStruct = definePattern('CaipAssetType', CAIP_ASSET_TYPE_REGEX);\n/**\n * A CAIP-19 asset ID identifier, i.e., a human-readable type of asset ID.\n */\nexport const CaipAssetIdStruct = definePattern('CaipAssetId', CAIP_ASSET_ID_REGEX);\n/**\n * A CAIP-19 asset type or asset ID identifier, i.e., a human-readable type of asset identifier.\n */\nexport const CaipAssetTypeOrIdStruct = definePattern('CaipAssetTypeOrId', CAIP_ASSET_TYPE_OR_ID_REGEX);\n/** Known CAIP namespaces. */\nexport var KnownCaipNamespace;\n(function (KnownCaipNamespace) {\n    /** BIP-122 (Bitcoin) compatible chains. */\n    KnownCaipNamespace[\"Bip122\"] = \"bip122\";\n    /** Solana compatible chains */\n    KnownCaipNamespace[\"Solana\"] = \"solana\";\n    /** EIP-155 compatible chains. */\n    KnownCaipNamespace[\"Eip155\"] = \"eip155\";\n    KnownCaipNamespace[\"Wallet\"] = \"wallet\";\n})(KnownCaipNamespace = KnownCaipNamespace || (KnownCaipNamespace = {}));\n/**\n * Check if the given value is a {@link CaipChainId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipChainId}.\n */\nexport function isCaipChainId(value) {\n    return is(value, CaipChainIdStruct);\n}\n/**\n * Check if the given value is a {@link CaipNamespace}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipNamespace}.\n */\nexport function isCaipNamespace(value) {\n    return is(value, CaipNamespaceStruct);\n}\n/**\n * Check if the given value is a {@link CaipReference}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipReference}.\n */\nexport function isCaipReference(value) {\n    return is(value, CaipReferenceStruct);\n}\n/**\n * Check if the given value is a {@link CaipAccountId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAccountId}.\n */\nexport function isCaipAccountId(value) {\n    return is(value, CaipAccountIdStruct);\n}\n/**\n * Check if a value is a {@link CaipAccountAddress}.\n *\n * @param value - The value to validate.\n * @returns True if the value is a valid {@link CaipAccountAddress}.\n */\nexport function isCaipAccountAddress(value) {\n    return is(value, CaipAccountAddressStruct);\n}\n/**\n * Check if the given value is a {@link CaipAssetNamespace}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetNamespace}.\n */\nexport function isCaipAssetNamespace(value) {\n    return is(value, CaipAssetNamespaceStruct);\n}\n/**\n * Check if the given value is a {@link CaipAssetReference}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetReference}.\n */\nexport function isCaipAssetReference(value) {\n    return is(value, CaipAssetReferenceStruct);\n}\n/**\n * Check if the given value is a {@link CaipTokenId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipTokenId}.\n */\nexport function isCaipTokenId(value) {\n    return is(value, CaipTokenIdStruct);\n}\n/**\n * Check if the given value is a {@link CaipAssetType}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetType}.\n */\nexport function isCaipAssetType(value) {\n    return is(value, CaipAssetTypeStruct);\n}\n/**\n * Check if the given value is a {@link CaipAssetId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetId}.\n */\nexport function isCaipAssetId(value) {\n    return is(value, CaipAssetIdStruct);\n}\n/**\n * Parse a CAIP-2 chain ID to an object containing the namespace and reference.\n * This validates the CAIP-2 chain ID before parsing it.\n *\n * @param caipChainId - The CAIP-2 chain ID to validate and parse.\n * @returns The parsed CAIP-2 chain ID.\n */\nexport function parseCaipChainId(caipChainId) {\n    const match = CAIP_CHAIN_ID_REGEX.exec(caipChainId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP chain ID.');\n    }\n    return {\n        namespace: match.groups.namespace,\n        reference: match.groups.reference,\n    };\n}\n/**\n * Parse an CAIP-10 account ID to an object containing the chain ID, parsed chain ID, and account address.\n * This validates the CAIP-10 account ID before parsing it.\n *\n * @param caipAccountId - The CAIP-10 account ID to validate and parse.\n * @returns The parsed CAIP-10 account ID.\n */\nexport function parseCaipAccountId(caipAccountId) {\n    const match = CAIP_ACCOUNT_ID_REGEX.exec(caipAccountId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP account ID.');\n    }\n    return {\n        address: match.groups.accountAddress,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference,\n        },\n    };\n}\n/**\n * Parse a CAIP-19 asset type to an object containing the chain ID, parsed chain ID,\n * asset namespace, and asset reference\n *\n * This validates the CAIP-19 asset type before parsing it.\n *\n * @param caipAssetType - The CAIP-19 asset type to validate and parse.\n * @returns The parsed CAIP-19 asset type.\n */\nexport function parseCaipAssetType(caipAssetType) {\n    const match = CAIP_ASSET_TYPE_REGEX.exec(caipAssetType);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP asset type.');\n    }\n    return {\n        assetNamespace: match.groups.assetNamespace,\n        assetReference: match.groups.assetReference,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference,\n        },\n    };\n}\n/**\n * Parse a CAIP-19 asset ID to an object containing the chain ID, parsed chain ID,\n * asset namespace, asset reference, and token ID.\n *\n * This validates the CAIP-19 asset ID before parsing it.\n *\n * @param caipAssetId - The CAIP-19 asset ID to validate and parse.\n * @returns The parsed CAIP-19 asset ID.\n */\nexport function parseCaipAssetId(caipAssetId) {\n    const match = CAIP_ASSET_ID_REGEX.exec(caipAssetId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP asset ID.');\n    }\n    return {\n        assetNamespace: match.groups.assetNamespace,\n        assetReference: match.groups.assetReference,\n        tokenId: match.groups.tokenId,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference,\n        },\n    };\n}\n/**\n * Chain ID as defined per the CAIP-2\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md}.\n *\n * It defines a way to uniquely identify any blockchain in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identify of a blockchain within a given namespace.\n * @throws {@link Error}\n * This exception is thrown if the inputs does not comply with the CAIP-2\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md#syntax}.\n * @returns A CAIP chain ID.\n */\nexport function toCaipChainId(namespace, reference) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}`;\n}\n/**\n * Account ID as defined per the CAIP-10\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md}.\n *\n * It defines a way to uniquely identify any blockchain account in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param accountAddress - The address of the blockchain account.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-10\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md#syntax}.\n * @returns A CAIP account ID.\n */\nexport function toCaipAccountId(namespace, reference, accountAddress) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipAccountAddress(accountAddress)) {\n        throw new Error(`Invalid \"accountAddress\", must match: ${CAIP_ACCOUNT_ADDRESS_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}:${accountAddress}`;\n}\n/**\n * Asset Type as defined per the CAIP-19\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md}.\n *\n * It defines a way to uniquely identify any blockchain asset in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param assetNamespace - The namespace domain of an asset.\n * @param assetReference - The identity of an asset within a given namespace.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-19\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md#syntax}.\n * @returns A CAIP asset type.\n */\nexport function toCaipAssetType(namespace, reference, assetNamespace, assetReference) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetNamespace(assetNamespace)) {\n        throw new Error(`Invalid \"assetNamespace\", must match: ${CAIP_ASSET_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetReference(assetReference)) {\n        throw new Error(`Invalid \"assetReference\", must match: ${CAIP_ASSET_REFERENCE_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}/${assetNamespace}:${assetReference}`;\n}\n/**\n * Asset ID as defined per the CAIP-19\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md}.\n *\n * It defines a way to uniquely identify any blockchain asset in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param assetNamespace - The namespace domain of an asset.\n * @param assetReference - The identity of an asset within a given namespace.\n * @param tokenId - The unique identifier for an addressable asset of a given type.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-19\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md#syntax}.\n * @returns A CAIP asset ID.\n */\nexport function toCaipAssetId(namespace, reference, assetNamespace, assetReference, tokenId) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetNamespace(assetNamespace)) {\n        throw new Error(`Invalid \"assetNamespace\", must match: ${CAIP_ASSET_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetReference(assetReference)) {\n        throw new Error(`Invalid \"assetReference\", must match: ${CAIP_ASSET_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipTokenId(tokenId)) {\n        throw new Error(`Invalid \"tokenId\", must match: ${CAIP_TOKEN_ID_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}/${assetNamespace}:${assetReference}/${tokenId}`;\n}\n//# sourceMappingURL=caip-types.mjs.map","import { AccountIdStruct, object } from \"@metamask/keyring-utils\";\nimport { nonempty, array, enums, string } from \"@metamask/superstruct\";\nimport { KeyringAccountOptionsStruct } from \"./account-options.mjs\";\nimport { CaipChainIdStruct } from \"./caip.mjs\";\n/**\n * Supported Ethereum account types.\n */\nexport var EthAccountType;\n(function (EthAccountType) {\n    EthAccountType[\"Eoa\"] = \"eip155:eoa\";\n    EthAccountType[\"Erc4337\"] = \"eip155:erc4337\";\n})(EthAccountType || (EthAccountType = {}));\n/**\n * Supported Bitcoin account types.\n */\nexport var BtcAccountType;\n(function (BtcAccountType) {\n    BtcAccountType[\"P2pkh\"] = \"bip122:p2pkh\";\n    BtcAccountType[\"P2sh\"] = \"bip122:p2sh\";\n    BtcAccountType[\"P2wpkh\"] = \"bip122:p2wpkh\";\n    BtcAccountType[\"P2tr\"] = \"bip122:p2tr\";\n})(BtcAccountType || (BtcAccountType = {}));\n/**\n * Supported Solana account types.\n */\nexport var SolAccountType;\n(function (SolAccountType) {\n    SolAccountType[\"DataAccount\"] = \"solana:data-account\";\n})(SolAccountType || (SolAccountType = {}));\n/**\n * Supported Tron account types.\n */\nexport var TrxAccountType;\n(function (TrxAccountType) {\n    TrxAccountType[\"Eoa\"] = \"tron:eoa\";\n})(TrxAccountType || (TrxAccountType = {}));\n/**\n * A generic account type. It can be used to represent any account type that is\n * not covered by the other account types. It only applies to non-EVM chains.\n */\nexport var AnyAccountType;\n(function (AnyAccountType) {\n    AnyAccountType[\"Account\"] = \"any:account\";\n})(AnyAccountType || (AnyAccountType = {}));\n/**\n * A struct which represents a Keyring account object. It is abstract enough to\n * be used with any blockchain. Specific blockchain account types should extend\n * this struct.\n *\n * See {@link KeyringAccount}.\n */\nexport const KeyringAccountStruct = object({\n    /**\n     * Account ID (UUIDv4).\n     */\n    id: AccountIdStruct,\n    /**\n     * Account type.\n     */\n    type: enums([\n        `${EthAccountType.Eoa}`,\n        `${EthAccountType.Erc4337}`,\n        `${BtcAccountType.P2pkh}`,\n        `${BtcAccountType.P2sh}`,\n        `${BtcAccountType.P2wpkh}`,\n        `${BtcAccountType.P2tr}`,\n        `${SolAccountType.DataAccount}`,\n        `${TrxAccountType.Eoa}`,\n        `${AnyAccountType.Account}`,\n    ]),\n    /**\n     * Account main address.\n     */\n    address: string(),\n    /**\n     * Account supported scopes (CAIP-2 chain IDs).\n     */\n    scopes: nonempty(array(CaipChainIdStruct)),\n    /**\n     * Account options.\n     */\n    options: KeyringAccountOptionsStruct,\n    /**\n     * Account supported methods.\n     */\n    methods: array(string()),\n});\n//# sourceMappingURL=account.mjs.map","import { object, selectiveUnion, StringNumberStruct } from \"@metamask/keyring-utils\";\nimport { literal, string } from \"@metamask/superstruct\";\nimport { CaipAssetIdStruct, CaipAssetTypeStruct, isPlainObject } from \"@metamask/utils\";\n/**\n * Fungible asset amount struct.\n */\nexport const FungibleAssetAmountStruct = object({\n    /**\n     * Asset unit.\n     */\n    unit: string(),\n    /**\n     * Asset amount.\n     */\n    amount: StringNumberStruct,\n});\n/**\n * Fungible asset struct.\n */\nexport const FungibleAssetStruct = object({\n    /**\n     * It is a fungible asset.\n     */\n    fungible: literal(true),\n    /**\n     * Asset type (CAIP-19).\n     */\n    type: CaipAssetTypeStruct,\n    ...FungibleAssetAmountStruct.schema,\n});\n/**\n * Non-fungible asset struct.\n */\nexport const NonFungibleAssetStruct = object({\n    /**\n     * It is a non-fungible asset.\n     */\n    fungible: literal(false),\n    /**\n     * Asset ID (CAIP-19).\n     */\n    id: CaipAssetIdStruct,\n});\n/**\n * Asset struct. This represents a fungible or non-fungible asset. Fungible\n * assets include an amount and a unit in addition to the asset type. While\n * non-fungible assets include only an asset ID.\n *\n * See {@link NonFungibleAssetStruct} and {@link FungibleAssetStruct}.\n *\n * All assets have a `fungible` property that is used to tag the union and\n * allow the following pattern:\n *\n * ```ts\n * if (asset.fungible) {\n *   // Use asset.type\n * } else {\n *   // Use asset.id\n * }\n * ```\n *\n * @example\n * ```ts\n * {\n *   fungible: true,\n *   type: 'eip155:1/slip44:60',\n *   unit: 'ETH',\n *   amount: '0.01',\n * }\n * ```\n *\n * @example\n * ```ts\n * {\n *   fungible: false,\n *   id: 'eip155:1/erc721:0x06012c8cf97BEaD5deAe237070F9587f8E7A266d/771769',\n * }\n * ```\n */\nexport const AssetStruct = selectiveUnion((value) => {\n    return isPlainObject(value) && !value.fungible\n        ? NonFungibleAssetStruct\n        : FungibleAssetStruct;\n});\n//# sourceMappingURL=asset.mjs.map","import { object } from \"@metamask/superstruct\";\nimport { CaipAccountIdStruct } from \"@metamask/utils\";\n/**\n * An account's address that has been resolved from a signing request.\n */\nexport const ResolvedAccountAddressStruct = object({\n    /**\n     * Account main address (CAIP-10 account ID).\n     */\n    address: CaipAccountIdStruct,\n});\n//# sourceMappingURL=address.mjs.map","import { object, StringNumberStruct } from \"@metamask/keyring-utils\";\nimport { string } from \"@metamask/superstruct\";\nexport const BalanceStruct = object({\n    amount: StringNumberStruct,\n    unit: string(),\n});\n//# sourceMappingURL=balance.mjs.map","import { definePattern } from \"@metamask/utils\";\nexport const DerivationPathStruct = definePattern('DerivationPath', /^m(?:\\/\\d+'?)+$/u);\n//# sourceMappingURL=derivation.mjs.map","import { array, literal, object } from \"@metamask/superstruct\";\nimport { CaipChainIdStruct } from \"./caip.mjs\";\nimport { DerivationPathStruct } from \"./derivation.mjs\";\n/**\n * Account type tag.\n *\n * The main use of this enum is to tag the {@link DiscoveredAccount} type for\n * future use.\n */\nexport var DiscoveredAccountType;\n(function (DiscoveredAccountType) {\n    // BIP-44 compatible accounts.\n    DiscoveredAccountType[\"Bip44\"] = \"bip44\";\n})(DiscoveredAccountType || (DiscoveredAccountType = {}));\n/**\n * This struct represents a discovered BIP-44 compatible account.\n *\n * It supports BIP-44 in a non-strict way. The derivation path MUST HAVE at\n * least 1 segment.\n */\nexport const DiscoveredBip44AccountStruct = object({\n    /**\n     * Account type.\n     */\n    type: literal(`${DiscoveredAccountType.Bip44}`),\n    /**\n     * Account supported scopes (CAIP-2 chain IDs).\n     */\n    scopes: array(CaipChainIdStruct),\n    /**\n     * The derivation path for this account. It MUST HAVE at least 1 segment.\n     */\n    derivationPath: DerivationPathStruct,\n});\n// Could become a union if we have new discovered account type.\nexport const DiscoveredAccountStruct = DiscoveredBip44AccountStruct;\n//# sourceMappingURL=discovery.mjs.map","import { record, string } from \"@metamask/superstruct\";\nimport { JsonStruct } from \"@metamask/utils\";\nexport const KeyringAccountDataStruct = record(string(), JsonStruct);\n//# sourceMappingURL=export.mjs.map","import { exactOptional, object, UuidStruct } from \"@metamask/keyring-utils\";\nimport { array, record, string, union } from \"@metamask/superstruct\";\nimport { JsonStruct } from \"@metamask/utils\";\nexport const KeyringRequestStruct = object({\n    /**\n     * Keyring request ID (UUIDv4).\n     */\n    id: UuidStruct,\n    /**\n     * Request's scope (CAIP-2 chain ID).\n     */\n    scope: string(),\n    /**\n     * Account ID (UUIDv4).\n     */\n    account: UuidStruct,\n    /**\n     * Origin of the sender.\n     */\n    origin: string(),\n    /**\n     * Inner request sent by the client application.\n     */\n    request: object({\n        method: string(),\n        params: exactOptional(union([array(JsonStruct), record(string(), JsonStruct)])),\n    }),\n});\n//# sourceMappingURL=request.mjs.map","import { exactOptional, object } from \"@metamask/keyring-utils\";\nimport { literal, string, union } from \"@metamask/superstruct\";\nimport { JsonStruct } from \"@metamask/utils\";\nexport const KeyringResponseStruct = union([\n    object({\n        /**\n         * Pending flag.\n         *\n         * Setting the pending flag to true indicates that the request will be\n         * handled asynchronously. The keyring must be called with `approveRequest`\n         * or `rejectRequest` to resolve the request.\n         */\n        pending: literal(true),\n        /**\n         * Redirect URL.\n         *\n         * If present in the response, MetaMask will display a confirmation dialog\n         * with a link to the redirect URL. The user can choose to follow the link\n         * or cancel the request.\n         */\n        redirect: exactOptional(object({\n            message: exactOptional(string()),\n            url: exactOptional(string()),\n        })),\n    }),\n    object({\n        /**\n         * Pending flag.\n         *\n         * Setting the pending flag to false indicates that the request will be\n         * handled synchronously. The keyring must return the result of the\n         * request execution.\n         */\n        pending: literal(false),\n        /**\n         * Request result.\n         */\n        result: JsonStruct,\n    }),\n]);\n//# sourceMappingURL=response.mjs.map","import { object, UuidStruct } from \"@metamask/keyring-utils\";\nimport { array, enums, nullable, number, string } from \"@metamask/superstruct\";\nimport { AssetStruct } from \"./asset.mjs\";\nimport { CaipChainIdStruct } from \"./caip.mjs\";\n/**\n * This struct represents a participant in a transaction.\n *\n * @example\n * ```ts\n * {\n *   address: '0x1234...',\n *   asset: {\n *     fungible: true,\n *     type: 'eip155:1/slip44:60',\n *     unit: 'ETH',\n *     amount: '0.01',\n *   },\n * },\n * ```\n *\n * @example\n * ```ts\n * {\n *   address: '0x1234...',\n *   asset: {\n *     fungible: false,\n *     id: 'eip155:1/erc721:0x06012c8cf97BEaD5deAe237070F9587f8E7A266d/771769',\n *   },\n * },\n * ```\n *\n * @example\n * ```ts\n * {\n *   address: '0x1234...',\n *   asset: null,\n * },\n * ```\n */\nconst ParticipantStruct = object({\n    /**\n     * Participant address.\n     */\n    address: string(),\n    /**\n     * Asset being transferred.\n     */\n    asset: nullable(AssetStruct),\n});\n/**\n * Fee types.\n */\nexport var FeeType;\n(function (FeeType) {\n    /**\n     * Base fee. It is the minimum fee required to include a transaction in the\n     * blockchain.\n     *\n     * For non-confirmed transactions, it must be the maximum base fee. For\n     * confirmed transactions, it must be the actual base fee paid.\n     */\n    FeeType[\"Base\"] = \"base\";\n    /**\n     * Priority fee. It is an optional fee used to prioritize the transaction.\n     *\n     * For non-confirmed transactions, it must be the maximum priority fee. For\n     * confirmed transactions, it must be the actual priority fee paid.\n     */\n    FeeType[\"Priority\"] = \"priority\";\n})(FeeType || (FeeType = {}));\n/**\n * This struct represents a transaction fee.\n */\nconst FeeStruct = object({\n    /**\n     * Fee type {@see FeeType}.\n     */\n    type: enums([`${FeeType.Base}`, `${FeeType.Priority}`]),\n    /**\n     * Asset used to pay for the fee.\n     */\n    asset: AssetStruct,\n});\n/**\n * Transaction statuses.\n */\nexport var TransactionStatus;\n(function (TransactionStatus) {\n    /**\n     * The transaction has been submitted but is not yet in the\n     * blockchain. For example, it can be in the mempool.\n     */\n    TransactionStatus[\"Submitted\"] = \"submitted\";\n    /**\n     * The transaction is in the blockchain but has not been\n     * confirmed yet.\n     */\n    TransactionStatus[\"Unconfirmed\"] = \"unconfirmed\";\n    /**\n     * The transaction has been confirmed.\n     */\n    TransactionStatus[\"Confirmed\"] = \"confirmed\";\n    /**\n     * The transaction has failed. For example, it has been reverted.\n     */\n    TransactionStatus[\"Failed\"] = \"failed\";\n})(TransactionStatus || (TransactionStatus = {}));\n/**\n * Transaction types.\n */\nexport var TransactionType;\n(function (TransactionType) {\n    /**\n     * The transaction was originated by the account. If the transaction\n     * has a change output that goes back to the same account, it must be tagged\n     * as a send transaction.\n     */\n    TransactionType[\"Send\"] = \"send\";\n    /**\n     * The transaction was received by the account, but originated by\n     * another account.\n     */\n    TransactionType[\"Receive\"] = \"receive\";\n    /**\n     * The transaction is a swap. It decreases the balance of one asset and\n     * increases the balance of another asset in a single transaction.\n     *\n     * A swap transaction must be originated by the account.\n     */\n    TransactionType[\"Swap\"] = \"swap\";\n    /**\n     * Represents an outgoing bridge transaction, transferring assets from\n     * the account to another blockchain.\n     */\n    TransactionType[\"BridgeSend\"] = \"bridge:send\";\n    /**\n     * Represents an incoming bridge transaction, transferring assets from\n     * another blockchain to the account.\n     */\n    TransactionType[\"BridgeReceive\"] = \"bridge:receive\";\n    /**\n     * The transaction type is unknown. It's not possible to determine the\n     * transaction type based on the information available.\n     */\n    TransactionType[\"Unknown\"] = \"unknown\";\n})(TransactionType || (TransactionType = {}));\n/**\n * This struct represents a transaction event.\n */\nexport const TransactionEventStruct = object({\n    /**\n     * New status of the transaction.\n     */\n    status: enums([\n        `${TransactionStatus.Submitted}`,\n        `${TransactionStatus.Unconfirmed}`,\n        `${TransactionStatus.Confirmed}`,\n        `${TransactionStatus.Failed}`,\n    ]),\n    /**\n     * UNIX timestamp of when the event occurred.\n     */\n    timestamp: nullable(number()),\n});\n/**\n * This struct represents a blockchain transaction.\n *\n * @example\n * ```ts\n * const tx = {\n *   id: 'f5d8ee39a430901c91a5917b9f2dc19d6d1a0e9cea205b009ca73dd04470b9a6',\n *   chain: 'bip122:000000000019d6689c085ae165831e93',\n *   account: 'b9beb861-9761-4b97-89ce-d992be5f34da',\n *   status: 'confirmed',\n *   timestamp: 1716367781,\n *   type: 'send',\n *   from: [\n *     {\n *       address: 'bc1qrp0yzgkf8rawkuvdlhnjfj2fnjwm0m8727kgah',\n *       asset: {\n *         fungible: true,\n *         type: 'bip122:000000000019d6689c085ae165831e93/slip44:0',\n *         unit: 'BTC',\n *         amount: '0.1',\n *       },\n *     },\n *   ],\n *   to: [\n *     {\n *       address: 'bc1qrp0yzgkf8rawkuvdlhnjfj2fnjwm0m8727kgah',\n *       asset: {\n *         fungible: true,\n *         type: 'bip122:000000000019d6689c085ae165831e93/slip44:0',\n *         unit: 'BTC',\n *         amount: '0.1',\n *       },\n *     },\n *     {\n *       address: 'bc1qwl8399fz829uqvqly9tcatgrgtwp3udnhxfq4k',\n *       asset: {\n *         fungible: true,\n *         type: 'bip122:000000000019d6689c085ae165831e93/slip44:0',\n *         unit: 'BTC',\n *         amount: '0.1',\n *       },\n *     },\n *   ],\n *   fees: [\n *     {\n *       type: 'priority',\n *       asset: {\n *         fungible: true,\n *         type: 'bip122:000000000019d6689c085ae165831e93/slip44:0',\n *         unit: 'BTC',\n *         amount: '0.1',\n *       },\n *     },\n *   ],\n * };\n * ```\n */\nexport const TransactionStruct = object({\n    /**\n     * Chain-specific transaction ID.\n     */\n    id: string(),\n    /**\n     * Chain ID (CAIP-2).\n     */\n    chain: CaipChainIdStruct,\n    /**\n     * Account ID (UUIDv4).\n     */\n    account: UuidStruct,\n    /**\n     * Transaction status {@see TransactionStatus}.\n     */\n    status: enums([\n        `${TransactionStatus.Submitted}`,\n        `${TransactionStatus.Unconfirmed}`,\n        `${TransactionStatus.Confirmed}`,\n        `${TransactionStatus.Failed}`,\n    ]),\n    /**\n     * UNIX timestamp of when the transaction was added to the blockchain. The\n     * timestamp can be null if the transaction has not been included in the\n     * blockchain yet.\n     */\n    timestamp: nullable(number()),\n    /**\n     * Transaction type {@see TransactionType}. This will be used by MetaMask to enrich the transaction\n     * details on the UI.\n     */\n    type: enums([\n        `${TransactionType.Send}`,\n        `${TransactionType.Receive}`,\n        `${TransactionType.Swap}`,\n        `${TransactionType.BridgeSend}`,\n        `${TransactionType.BridgeReceive}`,\n        `${TransactionType.Unknown}`,\n    ]),\n    /**\n     * Transaction sender addresses and amounts.\n     */\n    from: array(ParticipantStruct),\n    /**\n     * Transaction receiver addresses and amounts.\n     */\n    to: array(ParticipantStruct),\n    /**\n     * Total transaction fee.\n     */\n    fees: array(FeeStruct),\n    /**\n     * List of events related to the transaction {@see TransactionEventStruct}.\n     *\n     * The events are tracked in a best-effort basis and may not be available for\n     * all transactions.\n     */\n    events: array(TransactionEventStruct),\n});\n/**\n * This struct represents a page of transactions.\n *\n * @example\n * ```ts\n * {\n *   data: [\n *     {\n *       // Transaction object\n *     }\n *   ],\n *   next: 'c3y1Q6QtqtstbxKX+oqVdEW6',\n * }\n * ```\n *\n * @example\n * ```ts\n * {\n *   data: [\n *     {\n *       // Transaction object\n *     }\n *   ],\n *   next: null, // No more results\n * }**\n * ```\n */\nexport const TransactionsPageStruct = object({\n    /**\n     * List of transactions.\n     */\n    data: array(TransactionStruct),\n    /**\n     * Next cursor to iterate over the results. If null, there are no more\n     * results.\n     */\n    next: nullable(string()),\n});\n//# sourceMappingURL=transaction.mjs.map","import { exactOptional, object } from \"@metamask/keyring-utils\";\nimport { nullable, number, string } from \"@metamask/superstruct\";\n/**\n * Pagination struct. This struct is used to specify the limit of items to\n * return and the next cursor to iterate over the results.\n *\n * @example\n * ```ts\n * {\n *   limit: 10,\n *   next: 'c3y1Q6QtqtstbxKX+oqVdEW6',\n * }\n * ```\n */\nexport const PaginationStruct = object({\n    /**\n     * Maximum number of items to return.\n     */\n    limit: number(),\n    /**\n     * Next cursor to iterate over the results.\n     */\n    next: exactOptional(nullable(string())),\n});\n//# sourceMappingURL=pagination.mjs.map","import { exactOptional, object, UuidStruct } from \"@metamask/keyring-utils\";\nexport const MetaMaskOptionsStruct = object({\n    /**\n     * MetaMask internal options. The 'metamask' field will only be set when\n     * the keyring API is being used by a MetaMask client.\n     */\n    metamask: exactOptional(object({\n        /**\n         * Correlation ID that can be passed by MetaMask.\n         */\n        correlationId: UuidStruct,\n    })),\n});\n//# sourceMappingURL=options.mjs.map","// istanbul ignore file\n/**\n * Scopes for Bitcoin account type. See {@link KeyringAccount.scopes}.\n */\nexport var BtcScope;\n(function (BtcScope) {\n    BtcScope[\"Mainnet\"] = \"bip122:000000000019d6689c085ae165831e93\";\n    BtcScope[\"Testnet\"] = \"bip122:000000000933ea01ad0ee984209779ba\";\n    BtcScope[\"Testnet4\"] = \"bip122:00000000da84f2bafbbc53dee25a72ae\";\n    BtcScope[\"Signet\"] = \"bip122:00000008819873e925422c1ff0f99f7c\";\n    BtcScope[\"Regtest\"] = \"bip122:regtest\";\n})(BtcScope || (BtcScope = {}));\n//# sourceMappingURL=constants.mjs.map","import { object } from \"@metamask/keyring-utils\";\nimport { string, array, enums, refine, literal, nonempty } from \"@metamask/superstruct\";\nimport { AddressType, getAddressInfo } from \"bitcoin-address-validation\";\nimport { BtcAccountType, CaipChainIdStruct, KeyringAccountStruct } from \"../api/index.mjs\";\nconst validateAddress = (address, type) => {\n    try {\n        const addressInfo = getAddressInfo(address);\n        if (addressInfo.type === type) {\n            return true;\n        }\n        return new Error(`Invalid ${type} address`);\n    }\n    catch (error) {\n        return new Error(`Failed to decode ${type} address: ${error.message}`);\n    }\n};\nexport const BtcP2pkhAddressStruct = refine(string(), 'BtcP2pkhAddressStruct', (address) => {\n    return validateAddress(address, AddressType.p2pkh);\n});\nexport const BtcP2shAddressStruct = refine(string(), 'BtcP2shAddressStruct', (address) => {\n    return validateAddress(address, AddressType.p2sh);\n});\nexport const BtcP2wpkhAddressStruct = refine(string(), 'BtcP2wpkhAddressStruct', (address) => {\n    return validateAddress(address, AddressType.p2wpkh);\n});\nexport const BtcP2trAddressStruct = refine(string(), 'BtcP2trAddressStruct', (address) => {\n    return validateAddress(address, AddressType.p2tr);\n});\n/**\n * Supported Bitcoin methods.\n */\nexport var BtcMethod;\n(function (BtcMethod) {\n    BtcMethod[\"SignPsbt\"] = \"signPsbt\";\n    BtcMethod[\"ComputeFee\"] = \"computeFee\";\n    BtcMethod[\"FillPsbt\"] = \"fillPsbt\";\n    BtcMethod[\"BroadcastPsbt\"] = \"broadcastPsbt\";\n    BtcMethod[\"SendTransfer\"] = \"sendTransfer\";\n    BtcMethod[\"GetUtxo\"] = \"getUtxo\";\n    BtcMethod[\"ListUtxos\"] = \"listUtxos\";\n    BtcMethod[\"PublicDescriptor\"] = \"publicDescriptor\";\n    BtcMethod[\"SignMessage\"] = \"signMessage\";\n})(BtcMethod || (BtcMethod = {}));\nconst BtcAccountStruct = object({\n    ...KeyringAccountStruct.schema,\n    /**\n     * Account supported scopes (CAIP-2 chain ID).\n     */\n    scopes: nonempty(array(CaipChainIdStruct)),\n    /**\n     * Account supported methods.\n     */\n    methods: array(enums(Object.values(BtcMethod))),\n});\nexport const BtcP2pkhAccountStruct = object({\n    ...BtcAccountStruct.schema,\n    /**\n     * Account P2PKH address.\n     */\n    address: BtcP2pkhAddressStruct,\n    /**\n     * Account type.\n     */\n    type: literal(`${BtcAccountType.P2pkh}`),\n});\nexport const BtcP2shAccountStruct = object({\n    ...BtcAccountStruct.schema,\n    /**\n     * Account P2SH address.\n     */\n    address: BtcP2shAddressStruct,\n    /**\n     * Account type.\n     */\n    type: literal(`${BtcAccountType.P2sh}`),\n});\nexport const BtcP2wpkhAccountStruct = object({\n    ...BtcAccountStruct.schema,\n    /**\n     * Account P2WPKH address.\n     */\n    address: BtcP2wpkhAddressStruct,\n    /**\n     * Account type.\n     */\n    type: literal(`${BtcAccountType.P2wpkh}`),\n});\nexport const BtcP2trAccountStruct = object({\n    ...BtcAccountStruct.schema,\n    /**\n     * Account P2TR address.\n     */\n    address: BtcP2trAddressStruct,\n    /**\n     * Account type.\n     */\n    type: literal(`${BtcAccountType.P2tr}`),\n});\n//# sourceMappingURL=types.mjs.map","// istanbul ignore file\n/**\n * Scopes for Solana account type. See {@link KeyringAccount.scopes}.\n */\nexport var SolScope;\n(function (SolScope) {\n    SolScope[\"Devnet\"] = \"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1\";\n    SolScope[\"Mainnet\"] = \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\";\n    SolScope[\"Testnet\"] = \"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z\";\n})(SolScope || (SolScope = {}));\n//# sourceMappingURL=constants.mjs.map","import { object } from \"@metamask/keyring-utils\";\nimport { array, enums, literal, nonempty } from \"@metamask/superstruct\";\nimport { definePattern } from \"@metamask/utils\";\nimport { CaipChainIdStruct, KeyringAccountStruct, SolAccountType } from \"../api/index.mjs\";\n/**\n * Solana addresses are represented in the format of a 256-bit ed25519 public key and\n * are encoded using base58.\n * They are usually 32 to 44 characters long.\n */\nexport const SolAddressStruct = definePattern('SolAddress', /^[1-9A-HJ-NP-Za-km-z]{32,44}$/iu);\n/**\n * Supported Solana methods.\n */\nexport var SolMethod;\n(function (SolMethod) {\n    // General transaction methods\n    // @deprecated\n    // TODO: Remove this once the new methods are fully adopted\n    SolMethod[\"SendAndConfirmTransaction\"] = \"sendAndConfirmTransaction\";\n    SolMethod[\"SignAndSendTransaction\"] = \"signAndSendTransaction\";\n    SolMethod[\"SignTransaction\"] = \"signTransaction\";\n    SolMethod[\"SignMessage\"] = \"signMessage\";\n    SolMethod[\"SignIn\"] = \"signIn\";\n})(SolMethod || (SolMethod = {}));\nexport const SolDataAccountStruct = object({\n    ...KeyringAccountStruct.schema,\n    /**\n     * Account address.\n     */\n    address: SolAddressStruct,\n    /**\n     * Account type.\n     */\n    type: literal(`${SolAccountType.DataAccount}`),\n    /**\n     * Account supported scopes (CAIP-2 chain IDs).\n     */\n    scopes: nonempty(array(CaipChainIdStruct)),\n    /**\n     * Account supported methods.\n     */\n    methods: array(enums(Object.values(SolMethod))),\n});\n//# sourceMappingURL=types.mjs.map","// istanbul ignore file\n/**\n * Scopes for EVM account type. See {@link KeyringAccount.scopes}.\n */\nexport var EthScope;\n(function (EthScope) {\n    EthScope[\"Eoa\"] = \"eip155:0\";\n    EthScope[\"Mainnet\"] = \"eip155:1\";\n    EthScope[\"Testnet\"] = \"eip155:11155111\";\n})(EthScope || (EthScope = {}));\n//# sourceMappingURL=constants.mjs.map","import { object } from \"@metamask/keyring-utils\";\nimport { nonempty, array, enums, literal } from \"@metamask/superstruct\";\nimport { definePattern } from \"@metamask/utils\";\nimport { EthScope } from \"./index.mjs\";\nimport { CaipChainIdStruct, EthAccountType, KeyringAccountStruct } from \"../api/index.mjs\";\nexport const EthBytesStruct = definePattern('EthBytes', /^0x[0-9a-f]*$/iu);\nexport const EthAddressStruct = definePattern('EthAddress', /^0x[0-9a-f]{40}$/iu);\nexport const EthUint256Struct = definePattern('EthUint256', /^0x([1-9a-f][0-9a-f]*|0)$/iu);\n/**\n * Supported Ethereum methods.\n */\nexport var EthMethod;\n(function (EthMethod) {\n    // General signing methods\n    EthMethod[\"PersonalSign\"] = \"personal_sign\";\n    EthMethod[\"Sign\"] = \"eth_sign\";\n    EthMethod[\"SignTransaction\"] = \"eth_signTransaction\";\n    EthMethod[\"SignTypedDataV1\"] = \"eth_signTypedData_v1\";\n    EthMethod[\"SignTypedDataV3\"] = \"eth_signTypedData_v3\";\n    EthMethod[\"SignTypedDataV4\"] = \"eth_signTypedData_v4\";\n    // ERC-4337 methods\n    EthMethod[\"PrepareUserOperation\"] = \"eth_prepareUserOperation\";\n    EthMethod[\"PatchUserOperation\"] = \"eth_patchUserOperation\";\n    EthMethod[\"SignUserOperation\"] = \"eth_signUserOperation\";\n})(EthMethod || (EthMethod = {}));\nexport const EthEoaAccountStruct = object({\n    ...KeyringAccountStruct.schema,\n    /**\n     * Account address.\n     */\n    address: EthAddressStruct,\n    /**\n     * Account type.\n     */\n    type: literal(`${EthAccountType.Eoa}`),\n    /**\n     * Account scopes (must be ['eip155:0']).\n     */\n    scopes: nonempty(array(literal(EthScope.Eoa))),\n    /**\n     * Account supported methods.\n     */\n    methods: array(enums([\n        `${EthMethod.PersonalSign}`,\n        `${EthMethod.Sign}`,\n        `${EthMethod.SignTransaction}`,\n        `${EthMethod.SignTypedDataV1}`,\n        `${EthMethod.SignTypedDataV3}`,\n        `${EthMethod.SignTypedDataV4}`,\n    ])),\n});\nexport const EthErc4337AccountStruct = object({\n    ...KeyringAccountStruct.schema,\n    /**\n     * Account address.\n     */\n    address: EthAddressStruct,\n    /**\n     * Account type.\n     */\n    type: literal(`${EthAccountType.Erc4337}`),\n    /**\n     * Account supported scopes (CAIP-2 chain IDs).\n     */\n    scopes: nonempty(array(CaipChainIdStruct)),\n    /**\n     * Account supported methods.\n     */\n    methods: array(enums([\n        `${EthMethod.PersonalSign}`,\n        `${EthMethod.Sign}`,\n        `${EthMethod.SignTypedDataV1}`,\n        `${EthMethod.SignTypedDataV3}`,\n        `${EthMethod.SignTypedDataV4}`,\n        `${EthMethod.PrepareUserOperation}`,\n        `${EthMethod.PatchUserOperation}`,\n        `${EthMethod.SignUserOperation}`,\n    ])),\n});\n//# sourceMappingURL=types.mjs.map","import { exactOptional, object, UrlStruct } from \"@metamask/keyring-utils\";\nimport { EthAddressStruct, EthBytesStruct, EthUint256Struct } from \"../types.mjs\";\n/**\n * Struct of a UserOperation as defined by ERC-4337.\n *\n * @see https://eips.ethereum.org/EIPS/eip-4337#definitions\n */\nexport const EthUserOperationStruct = object({\n    sender: EthAddressStruct,\n    nonce: EthUint256Struct,\n    initCode: EthBytesStruct,\n    callData: EthBytesStruct,\n    callGasLimit: EthUint256Struct,\n    verificationGasLimit: EthUint256Struct,\n    preVerificationGas: EthUint256Struct,\n    maxFeePerGas: EthUint256Struct,\n    maxPriorityFeePerGas: EthUint256Struct,\n    paymasterAndData: EthBytesStruct,\n    signature: EthBytesStruct,\n});\n/**\n * Struct containing the most basic transaction information required to\n * construct a UserOperation.\n */\nexport const EthBaseTransactionStruct = object({\n    /**\n     * Address of the transaction recipient.\n     */\n    to: EthAddressStruct,\n    /**\n     * Amount of wei to transfer to the recipient.\n     */\n    value: EthUint256Struct,\n    /**\n     * Data to pass to the recipient.\n     */\n    data: EthBytesStruct,\n});\nexport const EthBaseUserOperationStruct = object({\n    nonce: EthUint256Struct,\n    initCode: EthBytesStruct,\n    callData: EthBytesStruct,\n    gasLimits: exactOptional(object({\n        callGasLimit: EthUint256Struct,\n        verificationGasLimit: EthUint256Struct,\n        preVerificationGas: EthUint256Struct,\n    })),\n    dummyPaymasterAndData: EthBytesStruct,\n    dummySignature: EthBytesStruct,\n    bundlerUrl: UrlStruct,\n});\nexport const EthUserOperationPatchStruct = object({\n    paymasterAndData: EthBytesStruct,\n    callGasLimit: exactOptional(EthUint256Struct),\n    verificationGasLimit: exactOptional(EthUint256Struct),\n    preVerificationGas: exactOptional(EthUint256Struct),\n});\n//# sourceMappingURL=types.mjs.map","// istanbul ignore file\n/**\n * Scopes for TRON account type. See {@link KeyringAccount.scopes}.\n */\nexport var TrxScope;\n(function (TrxScope) {\n    TrxScope[\"Mainnet\"] = \"tron:728126428\";\n    TrxScope[\"Nile\"] = \"tron:3448148188\";\n    TrxScope[\"Shasta\"] = \"tron:2494104990\";\n})(TrxScope || (TrxScope = {}));\n//# sourceMappingURL=constants.mjs.map","import { object } from \"@metamask/keyring-utils\";\nimport { array, enums, literal, nonempty } from \"@metamask/superstruct\";\nimport { definePattern } from \"@metamask/utils\";\nimport { CaipChainIdStruct, KeyringAccountStruct, TrxAccountType } from \"../api/index.mjs\";\n/**\n * TRON addresses are Base58-encoded strings that are exactly 34 characters long\n * and start with the letter 'T'.\n */\nexport const TrxAddressStruct = definePattern('TrxAddress', /^T[1-9A-HJ-NP-Za-km-z]{33}$/iu);\n/**\n * Supported TRON methods.\n */\nexport var TrxMethod;\n(function (TrxMethod) {\n    TrxMethod[\"SignMessageV2\"] = \"signMessageV2\";\n    TrxMethod[\"VerifyMessageV2\"] = \"verifyMessageV2\";\n})(TrxMethod || (TrxMethod = {}));\nexport const TrxEoaAccountStruct = object({\n    ...KeyringAccountStruct.schema,\n    /**\n     * Account address.\n     */\n    address: TrxAddressStruct,\n    /**\n     * Account type.\n     */\n    type: literal(`${TrxAccountType.Eoa}`),\n    /**\n     * Account supported scopes (CAIP-2 chain IDs).\n     */\n    scopes: nonempty(array(CaipChainIdStruct)),\n    /**\n     * Account supported methods.\n     */\n    methods: array(enums(Object.values(TrxMethod))),\n});\n//# sourceMappingURL=types.mjs.map","import { object, UuidStruct, JsonRpcRequestStruct } from \"@metamask/keyring-utils\";\nimport { array, literal, nullable, number, record, string, union } from \"@metamask/superstruct\";\nimport { JsonStruct } from \"@metamask/utils\";\nimport { CaipAssetTypeStruct, CaipAssetTypeOrIdStruct, CaipChainIdStruct, BalanceStruct, KeyringAccountDataStruct, KeyringAccountStruct, KeyringRequestStruct, KeyringResponseStruct, TransactionsPageStruct, PaginationStruct, CaipAccountIdStruct, DiscoveredAccountStruct } from \"./api/index.mjs\";\n/**\n * Keyring RPC methods used by the API.\n */\nexport var KeyringRpcMethod;\n(function (KeyringRpcMethod) {\n    KeyringRpcMethod[\"ListAccounts\"] = \"keyring_listAccounts\";\n    KeyringRpcMethod[\"GetAccount\"] = \"keyring_getAccount\";\n    KeyringRpcMethod[\"CreateAccount\"] = \"keyring_createAccount\";\n    KeyringRpcMethod[\"DiscoverAccounts\"] = \"keyring_discoverAccounts\";\n    KeyringRpcMethod[\"ListAccountAssets\"] = \"keyring_listAccountAssets\";\n    KeyringRpcMethod[\"ListAccountTransactions\"] = \"keyring_listAccountTransactions\";\n    KeyringRpcMethod[\"GetAccountBalances\"] = \"keyring_getAccountBalances\";\n    KeyringRpcMethod[\"ResolveAccountAddress\"] = \"keyring_resolveAccountAddress\";\n    KeyringRpcMethod[\"FilterAccountChains\"] = \"keyring_filterAccountChains\";\n    KeyringRpcMethod[\"UpdateAccount\"] = \"keyring_updateAccount\";\n    KeyringRpcMethod[\"DeleteAccount\"] = \"keyring_deleteAccount\";\n    KeyringRpcMethod[\"ExportAccount\"] = \"keyring_exportAccount\";\n    KeyringRpcMethod[\"ListRequests\"] = \"keyring_listRequests\";\n    KeyringRpcMethod[\"GetRequest\"] = \"keyring_getRequest\";\n    KeyringRpcMethod[\"SubmitRequest\"] = \"keyring_submitRequest\";\n    KeyringRpcMethod[\"ApproveRequest\"] = \"keyring_approveRequest\";\n    KeyringRpcMethod[\"RejectRequest\"] = \"keyring_rejectRequest\";\n})(KeyringRpcMethod || (KeyringRpcMethod = {}));\n/**\n * Check if a method is a keyring RPC method.\n *\n * @param method - Method to check.\n * @returns Whether the method is a keyring RPC method.\n */\nexport function isKeyringRpcMethod(method) {\n    return Object.values(KeyringRpcMethod).includes(method);\n}\n// ----------------------------------------------------------------------------\nconst CommonHeader = {\n    jsonrpc: literal('2.0'),\n    id: union([string(), number(), literal(null)]),\n};\n// ----------------------------------------------------------------------------\n// List accounts\nexport const ListAccountsRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_listAccounts'),\n});\nexport const ListAccountsResponseStruct = array(KeyringAccountStruct);\n// ----------------------------------------------------------------------------\n// Get account\nexport const GetAccountRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_getAccount'),\n    params: object({\n        id: UuidStruct,\n    }),\n});\nexport const GetAccountResponseStruct = KeyringAccountStruct;\n// ----------------------------------------------------------------------------\n// Create account\nexport const CreateAccountRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_createAccount'),\n    params: object({\n        options: record(string(), JsonStruct),\n    }),\n});\nexport const CreateAccountResponseStruct = KeyringAccountStruct;\n// ----------------------------------------------------------------------------\n// Discover accounts\nexport const DiscoverAccountsRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_discoverAccounts'),\n    params: object({\n        scopes: array(CaipChainIdStruct),\n        entropySource: string(),\n        groupIndex: number(),\n    }),\n});\nexport const DiscoverAccountsResponseStruct = array(DiscoveredAccountStruct);\n// ----------------------------------------------------------------------------\n// List account transactions\nexport const ListAccountTransactionsRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_listAccountTransactions'),\n    params: object({\n        id: UuidStruct,\n        pagination: PaginationStruct,\n    }),\n});\nexport const ListAccountTransactionsResponseStruct = TransactionsPageStruct;\n// ----------------------------------------------------------------------------\n// List account assets\nexport const ListAccountAssetsRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_listAccountAssets'),\n    params: object({\n        id: UuidStruct,\n    }),\n});\nexport const ListAccountAssetsResponseStruct = array(CaipAssetTypeOrIdStruct);\n// ----------------------------------------------------------------------------\n// Get account balances\nexport const GetAccountBalancesRequestStruct = object({\n    ...CommonHeader,\n    method: literal(`${KeyringRpcMethod.GetAccountBalances}`),\n    params: object({\n        id: UuidStruct,\n        assets: array(CaipAssetTypeStruct),\n    }),\n});\nexport const GetAccountBalancesResponseStruct = record(CaipAssetTypeStruct, BalanceStruct);\n// ----------------------------------------------------------------------------\n// Resolve account address\nexport const ResolveAccountAddressRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_resolveAccountAddress'),\n    params: object({\n        scope: CaipChainIdStruct,\n        request: JsonRpcRequestStruct,\n    }),\n});\nexport const ResolveAccountAddressResponseStruct = nullable(object({\n    address: CaipAccountIdStruct,\n}));\n// ----------------------------------------------------------------------------\n// Filter account chains\nexport const FilterAccountChainsStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_filterAccountChains'),\n    params: object({\n        id: UuidStruct,\n        chains: array(string()),\n    }),\n});\nexport const FilterAccountChainsResponseStruct = array(string());\n// ----------------------------------------------------------------------------\n// Update account\nexport const UpdateAccountRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_updateAccount'),\n    params: object({\n        account: KeyringAccountStruct,\n    }),\n});\nexport const UpdateAccountResponseStruct = literal(null);\n// ----------------------------------------------------------------------------\n// Delete account\nexport const DeleteAccountRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_deleteAccount'),\n    params: object({\n        id: UuidStruct,\n    }),\n});\nexport const DeleteAccountResponseStruct = literal(null);\n// ----------------------------------------------------------------------------\n// Export account\nexport const ExportAccountRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_exportAccount'),\n    params: object({\n        id: UuidStruct,\n    }),\n});\nexport const ExportAccountResponseStruct = KeyringAccountDataStruct;\n// ----------------------------------------------------------------------------\n// List requests\nexport const ListRequestsRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_listRequests'),\n});\nexport const ListRequestsResponseStruct = array(KeyringRequestStruct);\n// ----------------------------------------------------------------------------\n// Get request\nexport const GetRequestRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_getRequest'),\n    params: object({\n        id: UuidStruct,\n    }),\n});\nexport const GetRequestResponseStruct = KeyringRequestStruct;\n// ----------------------------------------------------------------------------\n// Submit request\nexport const SubmitRequestRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_submitRequest'),\n    params: KeyringRequestStruct,\n});\nexport const SubmitRequestResponseStruct = KeyringResponseStruct;\n// ----------------------------------------------------------------------------\n// Approve request\nexport const ApproveRequestRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_approveRequest'),\n    params: object({\n        id: UuidStruct,\n        data: record(string(), JsonStruct),\n    }),\n});\nexport const ApproveRequestResponseStruct = literal(null);\n// ----------------------------------------------------------------------------\n// Reject request\nexport const RejectRequestRequestStruct = object({\n    ...CommonHeader,\n    method: literal('keyring_rejectRequest'),\n    params: object({\n        id: UuidStruct,\n    }),\n});\nexport const RejectRequestResponseStruct = literal(null);\n//# sourceMappingURL=rpc.mjs.map","/* eslint-disable @typescript-eslint/no-redundant-type-constituents */\n// FIXME: This rule seems to be triggering a false positive on the `KeyringEvents`.\nimport { exactOptional, object, UuidStruct, AccountIdStruct } from \"@metamask/keyring-utils\";\nimport { array, boolean, literal, record, string } from \"@metamask/superstruct\";\nimport { CaipAssetTypeStruct, CaipAssetTypeOrIdStruct, JsonStruct } from \"@metamask/utils\";\nimport { FungibleAssetAmountStruct, KeyringAccountStruct, TransactionStruct, MetaMaskOptionsStruct } from \"./api/index.mjs\";\n/**\n * Supported keyring events.\n */\nexport var KeyringEvent;\n(function (KeyringEvent) {\n    // Account events\n    KeyringEvent[\"AccountCreated\"] = \"notify:accountCreated\";\n    KeyringEvent[\"AccountUpdated\"] = \"notify:accountUpdated\";\n    KeyringEvent[\"AccountDeleted\"] = \"notify:accountDeleted\";\n    // Request events\n    KeyringEvent[\"RequestApproved\"] = \"notify:requestApproved\";\n    KeyringEvent[\"RequestRejected\"] = \"notify:requestRejected\";\n    // Assets related events\n    KeyringEvent[\"AccountBalancesUpdated\"] = \"notify:accountBalancesUpdated\";\n    KeyringEvent[\"AccountAssetListUpdated\"] = \"notify:accountAssetListUpdated\";\n    KeyringEvent[\"AccountTransactionsUpdated\"] = \"notify:accountTransactionsUpdated\";\n})(KeyringEvent || (KeyringEvent = {}));\nexport const AccountCreatedEventStruct = object({\n    method: literal(`${KeyringEvent.AccountCreated}`),\n    params: object({\n        /**\n         * New account object.\n         */\n        account: KeyringAccountStruct,\n        /**\n         * Account name suggestion provided to the MetaMask client.\n         *\n         * The keyring can suggest a name for the account, but it's up to the\n         * client to decide whether to use it. The keyring won't be informed if the\n         * client decides to use a different name.\n         */\n        accountNameSuggestion: exactOptional(string()),\n        /**\n         * Instructs MetaMask to display the add account confirmation dialog in the UI.\n         *\n         * **Note:** This is not guaranteed to be honored by the MetaMask client.\n         */\n        displayConfirmation: exactOptional(boolean()),\n        /**\n         * Instructs MetaMask to display the name confirmation dialog in the UI.\n         * Otherwise, the account will be added with the suggested name, if it's not\n         * already in use; if it is, a suffix will be appended to the name to make it\n         * unique.\n         *\n         * **Note:** This is not guaranteed to be honored by the MetaMask client.\n         */\n        displayAccountNameSuggestion: exactOptional(boolean()),\n        /**\n         * Metamask internal options.\n         */\n        ...MetaMaskOptionsStruct.schema,\n    }),\n});\nexport const AccountUpdatedEventStruct = object({\n    method: literal(`${KeyringEvent.AccountUpdated}`),\n    params: object({\n        /**\n         * Updated account object.\n         */\n        account: KeyringAccountStruct,\n    }),\n});\nexport const AccountDeletedEventStruct = object({\n    method: literal(`${KeyringEvent.AccountDeleted}`),\n    params: object({\n        /**\n         * Deleted account ID.\n         */\n        id: UuidStruct,\n    }),\n});\nexport const RequestApprovedEventStruct = object({\n    method: literal(`${KeyringEvent.RequestApproved}`),\n    params: object({\n        /**\n         * Request ID.\n         */\n        id: UuidStruct,\n        /**\n         * Request result.\n         */\n        result: JsonStruct,\n    }),\n});\nexport const RequestRejectedEventStruct = object({\n    method: literal(`${KeyringEvent.RequestRejected}`),\n    params: object({\n        /**\n         * Request ID.\n         */\n        id: UuidStruct,\n    }),\n});\n// Assets related events:\n// -----------------------------------------------------------------------------------------------\n/**\n * Event emitted when the balances of an account are updated.\n *\n * Only changes are reported.\n *\n * The Snap can choose to emit this event for multiple accounts at once.\n */\nexport const AccountBalancesUpdatedEventStruct = object({\n    method: literal(`${KeyringEvent.AccountBalancesUpdated}`),\n    params: object({\n        /**\n         * Balances updates of accounts owned by the Snap.\n         */\n        balances: record(\n        /**\n         * Account ID.\n         */\n        AccountIdStruct, \n        /**\n         * Mapping of each owned assets and their respective balances for that account.\n         */\n        record(\n        /**\n         * Asset type (CAIP-19).\n         */\n        CaipAssetTypeStruct, \n        /**\n         * Balance information for a given asset.\n         */\n        FungibleAssetAmountStruct)),\n    }),\n});\n/**\n * Event emitted when the transactions of an account are updated (added or\n * changed).\n *\n * Only changes are reported.\n *\n * The Snap can choose to emit this event for multiple accounts at once.\n */\nexport const AccountTransactionsUpdatedEventStruct = object({\n    method: literal(`${KeyringEvent.AccountTransactionsUpdated}`),\n    params: object({\n        /**\n         * Transactions updates of accounts owned by the Snap.\n         */\n        transactions: record(\n        /**\n         * Account ID.\n         */\n        AccountIdStruct, \n        /**\n         * List of updated transactions for that account.\n         */\n        array(TransactionStruct)),\n    }),\n});\n/**\n * Event emitted when the assets of an account are updated.\n *\n * Only changes are reported.\n *\n * The Snap can choose to emit this event for multiple accounts at once.\n */\nexport const AccountAssetListUpdatedEventStruct = object({\n    method: literal(`${KeyringEvent.AccountAssetListUpdated}`),\n    params: object({\n        /**\n         * Asset list update of accounts owned by the Snap.\n         */\n        assets: record(\n        /**\n         * Account ID.\n         */\n        AccountIdStruct, \n        /**\n         * Asset list changes for that account.\n         */\n        object({\n            /**\n             * New assets detected.\n             */\n            added: array(CaipAssetTypeOrIdStruct),\n            /**\n             * Assets no longer available on that account.\n             */\n            removed: array(CaipAssetTypeOrIdStruct),\n        })),\n    }),\n});\n//# sourceMappingURL=events.mjs.map","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _KeyringClient_sender;\nimport { ApproveRequestResponseStruct, CreateAccountResponseStruct, DeleteAccountResponseStruct, ExportAccountResponseStruct, FilterAccountChainsResponseStruct, GetAccountBalancesResponseStruct, GetAccountResponseStruct, GetRequestResponseStruct, ListAccountsResponseStruct, ListAccountTransactionsResponseStruct, ListAccountAssetsResponseStruct, ListRequestsResponseStruct, RejectRequestResponseStruct, SubmitRequestResponseStruct, UpdateAccountResponseStruct, KeyringRpcMethod, ResolveAccountAddressResponseStruct, DiscoverAccountsResponseStruct } from \"@metamask/keyring-api\";\nimport { strictMask } from \"@metamask/keyring-utils\";\nimport { assert } from \"@metamask/superstruct\";\nimport { v4 as uuid } from \"uuid\";\nexport class KeyringClient {\n    /**\n     * Create a new instance of `KeyringClient`.\n     *\n     * @param sender - The `Sender` instance to use to send requests to the snap.\n     */\n    constructor(sender) {\n        _KeyringClient_sender.set(this, void 0);\n        __classPrivateFieldSet(this, _KeyringClient_sender, sender, \"f\");\n    }\n    /**\n     * Send a request to the snap and return the response.\n     *\n     * @param partial - A partial JSON-RPC request (method and params).\n     * @returns A promise that resolves to the response to the request.\n     */\n    async send(partial) {\n        return __classPrivateFieldGet(this, _KeyringClient_sender, \"f\").send({\n            jsonrpc: '2.0',\n            id: uuid(),\n            ...partial,\n        });\n    }\n    async listAccounts() {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.ListAccounts,\n        }), ListAccountsResponseStruct);\n    }\n    async getAccount(id) {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.GetAccount,\n            params: { id },\n        }), GetAccountResponseStruct);\n    }\n    async getAccountBalances(id, assets) {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.GetAccountBalances,\n            params: { id, assets },\n        }), GetAccountBalancesResponseStruct);\n    }\n    async createAccount(options = {}) {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.CreateAccount,\n            params: { options },\n        }), CreateAccountResponseStruct);\n    }\n    async discoverAccounts(scopes, entropySource, groupIndex) {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.DiscoverAccounts,\n            params: { scopes, entropySource, groupIndex },\n        }), DiscoverAccountsResponseStruct);\n    }\n    async listAccountTransactions(id, pagination) {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.ListAccountTransactions,\n            params: { id, pagination },\n        }), ListAccountTransactionsResponseStruct);\n    }\n    async listAccountAssets(id) {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.ListAccountAssets,\n            params: { id },\n        }), ListAccountAssetsResponseStruct);\n    }\n    async resolveAccountAddress(scope, request) {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.ResolveAccountAddress,\n            params: { scope, request },\n        }), ResolveAccountAddressResponseStruct);\n    }\n    async filterAccountChains(id, chains) {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.FilterAccountChains,\n            params: { id, chains },\n        }), FilterAccountChainsResponseStruct);\n    }\n    async updateAccount(account) {\n        assert(await this.send({\n            method: KeyringRpcMethod.UpdateAccount,\n            params: { account },\n        }), UpdateAccountResponseStruct);\n    }\n    async deleteAccount(id) {\n        assert(await this.send({\n            method: KeyringRpcMethod.DeleteAccount,\n            params: { id },\n        }), DeleteAccountResponseStruct);\n    }\n    async exportAccount(id) {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.ExportAccount,\n            params: { id },\n        }), ExportAccountResponseStruct);\n    }\n    async listRequests() {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.ListRequests,\n        }), ListRequestsResponseStruct);\n    }\n    async getRequest(id) {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.GetRequest,\n            params: { id },\n        }), GetRequestResponseStruct);\n    }\n    async submitRequest(request) {\n        return strictMask(await this.send({\n            method: KeyringRpcMethod.SubmitRequest,\n            params: request,\n        }), SubmitRequestResponseStruct);\n    }\n    async approveRequest(id, data = {}) {\n        assert(await this.send({\n            method: KeyringRpcMethod.ApproveRequest,\n            params: { id, data },\n        }), ApproveRequestResponseStruct);\n    }\n    async rejectRequest(id) {\n        assert(await this.send({\n            method: KeyringRpcMethod.RejectRequest,\n            params: { id },\n        }), RejectRequestResponseStruct);\n    }\n}\n_KeyringClient_sender = new WeakMap();\n//# sourceMappingURL=KeyringClient.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _KeyringPublicClient_client;\nimport { KeyringRpcMethod } from \"@metamask/keyring-api\";\nimport { KeyringClient } from \"./KeyringClient.mjs\";\n/**\n * Public methods list.\n */\nexport const KeyringPublicRpcMethod = [\n    KeyringRpcMethod.CreateAccount,\n    KeyringRpcMethod.GetAccount,\n    KeyringRpcMethod.UpdateAccount,\n    KeyringRpcMethod.DeleteAccount,\n    KeyringRpcMethod.ExportAccount,\n    KeyringRpcMethod.ListAccounts,\n    KeyringRpcMethod.FilterAccountChains,\n    KeyringRpcMethod.GetRequest,\n    KeyringRpcMethod.ApproveRequest,\n    KeyringRpcMethod.RejectRequest,\n    KeyringRpcMethod.ListRequests,\n];\n/**\n * A client that can be used by companion dapp. Only some keyring methods are\n * available with this client.\n */\nexport class KeyringPublicClient {\n    /**\n     * Create a new instance of `KeyringPublicClient`.\n     *\n     * @param sender - The `Sender` instance to use to send requests to the snap.\n     */\n    constructor(sender) {\n        _KeyringPublicClient_client.set(this, void 0);\n        __classPrivateFieldSet(this, _KeyringPublicClient_client, new KeyringClient(sender), \"f\");\n    }\n    async createAccount(options) {\n        return __classPrivateFieldGet(this, _KeyringPublicClient_client, \"f\").createAccount(options);\n    }\n    async deleteAccount(id) {\n        return __classPrivateFieldGet(this, _KeyringPublicClient_client, \"f\").deleteAccount(id);\n    }\n    async listAccounts() {\n        return __classPrivateFieldGet(this, _KeyringPublicClient_client, \"f\").listAccounts();\n    }\n    async getAccount(id) {\n        return __classPrivateFieldGet(this, _KeyringPublicClient_client, \"f\").getAccount(id);\n    }\n    async getRequest(id) {\n        return __classPrivateFieldGet(this, _KeyringPublicClient_client, \"f\").getRequest(id);\n    }\n    async listRequests() {\n        return __classPrivateFieldGet(this, _KeyringPublicClient_client, \"f\").listRequests();\n    }\n    async updateAccount(account) {\n        return __classPrivateFieldGet(this, _KeyringPublicClient_client, \"f\").updateAccount(account);\n    }\n    async approveRequest(id, data) {\n        return __classPrivateFieldGet(this, _KeyringPublicClient_client, \"f\").approveRequest(id, data);\n    }\n    async rejectRequest(id) {\n        return __classPrivateFieldGet(this, _KeyringPublicClient_client, \"f\").rejectRequest(id);\n    }\n    async filterAccountChains(id, chains) {\n        return __classPrivateFieldGet(this, _KeyringPublicClient_client, \"f\").filterAccountChains(id, chains);\n    }\n    async exportAccount(id) {\n        return __classPrivateFieldGet(this, _KeyringPublicClient_client, \"f\").exportAccount(id);\n    }\n}\n_KeyringPublicClient_client = new WeakMap();\n//# sourceMappingURL=KeyringPublicClient.mjs.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _SnapRpcSender_origin, _SnapRpcSender_provider;\nimport { KeyringPublicClient } from \"./KeyringPublicClient.mjs\";\n/**\n * Implementation of the `Sender` interface that can be used to send requests\n * to a snap through the snap JSON-RPC API.\n */\nexport class SnapRpcSender {\n    /**\n     * Create a new instance of `SnapRpcSender`.\n     *\n     * @param origin - The caller's origin.\n     * @param provider - The `MetaMaskInpageProvider` instance to use.\n     */\n    constructor(origin, provider) {\n        _SnapRpcSender_origin.set(this, void 0);\n        _SnapRpcSender_provider.set(this, void 0);\n        __classPrivateFieldSet(this, _SnapRpcSender_origin, origin, \"f\");\n        __classPrivateFieldSet(this, _SnapRpcSender_provider, provider, \"f\");\n    }\n    /**\n     * Send a request to the snap and return the response.\n     *\n     * @param request - The JSON-RPC request to send to the snap.\n     * @returns A promise that resolves to the response of the request.\n     */\n    async send(request) {\n        return __classPrivateFieldGet(this, _SnapRpcSender_provider, \"f\").request({\n            method: 'wallet_invokeKeyring',\n            params: {\n                snapId: __classPrivateFieldGet(this, _SnapRpcSender_origin, \"f\"),\n                request,\n            },\n        });\n    }\n}\n_SnapRpcSender_origin = new WeakMap(), _SnapRpcSender_provider = new WeakMap();\n/**\n * A client that allows the communication with a snap through the snap\n * JSON-RPC API to call keyring methods.\n */\nexport class KeyringSnapRpcClient extends KeyringPublicClient {\n    /**\n     * Create a new instance of `KeyringSnapRpcClient`.\n     *\n     * @param origin - Caller's origin.\n     * @param provider - The `MetaMaskInpageProvider` instance to use.\n     */\n    constructor(origin, provider) {\n        super(new SnapRpcSender(origin, provider));\n    }\n}\n//# sourceMappingURL=KeyringSnapRpcClient.mjs.map","import type { KeyringAccount, KeyringRequest } from '@metamask/keyring-api';\nimport { KeyringSnapRpcClient } from '@metamask/keyring-snap-client';\nimport Grid from '@mui/material/Grid';\nimport React, { useCallback, useContext, useEffect, useState } from 'react';\n\nimport {\n  Accordion,\n  AccountList,\n  Card,\n  ConnectButton,\n  Toggle,\n} from '../components';\nimport {\n  CardContainer,\n  Container,\n  Divider,\n  DividerTitle,\n  StyledBox,\n} from '../components/styledComponents';\nimport { defaultSnapOrigin } from '../config';\nimport { MetaMaskContext, MetamaskActions } from '../hooks';\nimport { InputType } from '../types';\nimport type { KeyringState } from '../utils';\nimport {\n  connectSnap,\n  getSnap,\n  isSynchronousMode,\n  toggleSynchronousApprovals,\n} from '../utils';\n\nconst snapId = defaultSnapOrigin;\n\nconst initialState: {\n  pendingRequests: KeyringRequest[];\n  accounts: KeyringAccount[];\n  useSynchronousApprovals: boolean;\n} = {\n  pendingRequests: [],\n  accounts: [],\n  useSynchronousApprovals: true,\n};\n\nconst Index = () => {\n  const [state, dispatch] = useContext(MetaMaskContext);\n  const [snapState, setSnapState] = useState<KeyringState>(initialState);\n  // Is not a good practice to store sensitive data in the state of\n  // a component but for this case it should be ok since this is an\n  // internal development and testing tool.\n  const [privateKey, setPrivateKey] = useState<string | null>();\n  const [accountId, setAccountId] = useState<string | null>();\n  const [accountObject, setAccountObject] = useState<string | null>();\n  const [requestId, setRequestId] = useState<string | null>(null);\n  // const [accountPayload, setAccountPayload] =\n  //   useState<Pick<KeyringAccount, 'name' | 'options'>>();\n  const client = new KeyringSnapRpcClient(snapId, window.ethereum);\n\n  useEffect(() => {\n    /**\n     * Return the current state of the snap.\n     *\n     * @returns The current state of the snap.\n     */\n    async function getState() {\n      if (!state.installedSnap) {\n        return;\n      }\n      const accounts = await client.listAccounts();\n      const pendingRequests = await client.listRequests();\n      const isSynchronous = await isSynchronousMode();\n      setSnapState({\n        accounts,\n        pendingRequests,\n        useSynchronousApprovals: isSynchronous,\n      });\n    }\n\n    getState().catch((error) => console.error(error));\n  }, [state.installedSnap]);\n\n  const syncAccounts = async () => {\n    const accounts = await client.listAccounts();\n    setSnapState({\n      ...snapState,\n      accounts,\n    });\n  };\n\n  const createAccount = async () => {\n    const newAccount = await client.createAccount();\n    await syncAccounts();\n    return newAccount;\n  };\n\n  const importAccount = async () => {\n    const newAccount = await client.createAccount({\n      privateKey: privateKey as string,\n    });\n    await syncAccounts();\n    return newAccount;\n  };\n\n  const deleteAccount = async () => {\n    await client.deleteAccount(accountId as string);\n    await syncAccounts();\n  };\n\n  const updateAccount = async () => {\n    if (!accountObject) {\n      return;\n    }\n    const account: KeyringAccount = JSON.parse(accountObject);\n    await client.updateAccount(account);\n    await syncAccounts();\n  };\n\n  const handleConnectClick = async () => {\n    try {\n      await connectSnap();\n      const installedSnap = await getSnap();\n\n      dispatch({\n        type: MetamaskActions.SetInstalled,\n        payload: installedSnap,\n      });\n    } catch (error) {\n      console.error(error);\n      dispatch({ type: MetamaskActions.SetError, payload: error });\n    }\n  };\n\n  const handleUseSyncToggle = useCallback(async () => {\n    console.log('Toggling synchronous approval');\n    await toggleSynchronousApprovals();\n    setSnapState({\n      ...snapState,\n      useSynchronousApprovals: !snapState.useSynchronousApprovals,\n    });\n  }, [snapState]);\n\n  const accountManagementMethods = [\n    {\n      name: 'Create account',\n      description: 'Create a new account',\n      inputs: [],\n      action: {\n        callback: async () => await createAccount(),\n        label: 'Create Account',\n      },\n      successMessage: 'Account created',\n    },\n    {\n      name: 'Import account',\n      description: 'Import an account using a private key',\n      inputs: [\n        {\n          id: 'import-account-private-key',\n          title: 'Private key',\n          value: privateKey,\n          type: InputType.TextField,\n          placeholder:\n            'E.g. 0000000000000000000000000000000000000000000000000000000000000000',\n          onChange: (event: any) => setPrivateKey(event.currentTarget.value),\n        },\n      ],\n      action: {\n        callback: async () => await importAccount(),\n        label: 'Import Account',\n      },\n      successMessage: 'Account imported',\n    },\n    {\n      name: 'Get account',\n      description: 'Get data of the selected account',\n      inputs: [\n        {\n          id: 'get-account-account-id',\n          title: 'Account ID',\n          type: InputType.TextField,\n          placeholder: 'E.g. f59a9562-96de-4e75-9229-079e82c7822a',\n          options: snapState.accounts.map((account) => {\n            return { value: account.address };\n          }),\n          onChange: (event: any) => setAccountId(event.currentTarget.value),\n        },\n      ],\n      action: {\n        disabled: Boolean(accountId),\n        callback: async () => await client.getAccount(accountId as string),\n        label: 'Get Account',\n      },\n      successMessage: 'Account fetched',\n    },\n    {\n      name: 'List accounts',\n      description: 'List all account managed by the SSK',\n      action: {\n        disabled: false,\n        callback: async () => {\n          const accounts = await client.listAccounts();\n          setSnapState({\n            ...snapState,\n            accounts,\n          });\n          return accounts;\n        },\n        label: 'List Accounts',\n      },\n    },\n    {\n      name: 'Remove account',\n      description: 'Remove an account',\n      inputs: [\n        {\n          id: 'delete-account-account-id',\n          title: 'Account ID',\n          type: InputType.TextField,\n          placeholder: 'E.g. 394bd587-7be4-4ffb-a113-198c6a7764c2',\n          options: snapState.accounts.map((account) => {\n            return { value: account.address };\n          }),\n          onChange: (event: any) => setAccountId(event.currentTarget.value),\n        },\n      ],\n      action: {\n        disabled: Boolean(accountId),\n        callback: async () => await deleteAccount(),\n        label: 'Remove Account',\n      },\n      successMessage: 'Account Removed',\n    },\n    {\n      name: 'Update account',\n      description: 'Update an account',\n      inputs: [\n        {\n          id: 'update-account-account-object',\n          title: 'Account Object',\n          type: InputType.TextArea,\n          placeholder: 'E.g. { id: ... }',\n          onChange: (event: any) => setAccountObject(event.currentTarget.value),\n        },\n      ],\n      action: {\n        disabled: Boolean(accountId),\n        callback: async () => await updateAccount(),\n        label: 'Update Account',\n      },\n      successMessage: 'Account Updated',\n    },\n  ];\n\n  const requestMethods = [\n    {\n      name: 'Get request',\n      description: 'Get a pending request by ID',\n      inputs: [\n        {\n          id: 'get-request-request-id',\n          title: 'Request ID',\n          type: InputType.TextField,\n          placeholder: 'E.g. e5156958-16ad-4d5d-9dcd-6a8ba1d34906',\n          onChange: (event: any) => setRequestId(event.currentTarget.value),\n        },\n      ],\n      action: {\n        enabled: Boolean(requestId),\n        callback: async () => await client.getRequest(requestId as string),\n        label: 'Get Request',\n      },\n    },\n    {\n      name: 'List requests',\n      description: 'List pending requests',\n      action: {\n        disabled: false,\n        callback: async () => {\n          const requests = await client.listRequests();\n          setSnapState({\n            ...snapState,\n            pendingRequests: requests,\n          });\n          return requests;\n        },\n        label: 'List Requests',\n      },\n    },\n    {\n      name: 'Approve request',\n      description: 'Approve a pending request by ID',\n      inputs: [\n        {\n          id: 'approve-request-request-id',\n          title: 'Request ID',\n          type: InputType.TextField,\n          placeholder: 'E.g. 6fcbe1b5-f250-452c-8114-683dfa5ea74d',\n          onChange: (event: any) => {\n            setRequestId(event.currentTarget.value);\n          },\n        },\n      ],\n      action: {\n        disabled: !requestId,\n        callback: async () => await client.approveRequest(requestId as string),\n        label: 'Approve Request',\n      },\n      successMessage: 'Request approved',\n    },\n    {\n      name: 'Reject request',\n      description: 'Reject a pending request by ID',\n      inputs: [\n        {\n          id: 'reject-request-request-id',\n          title: 'Request ID',\n          type: InputType.TextField,\n          placeholder: 'E.g. 424ad2ee-56cf-493e-af82-cee79c591117',\n          onChange: (event: any) => {\n            setRequestId(event.currentTarget.value);\n          },\n        },\n      ],\n      action: {\n        disabled: !requestId,\n        callback: async () => await client.rejectRequest(requestId as string),\n        label: 'Reject Request',\n      },\n      successMessage: 'Request Rejected',\n    },\n  ];\n\n  return (\n    <Container>\n      <CardContainer>\n        {!state.installedSnap && (\n          <Card\n            content={{\n              title: 'Connect',\n              description:\n                'Get started by connecting to and installing the example snap.',\n              button: (\n                <ConnectButton\n                  onClick={handleConnectClick}\n                  disabled={!state.hasMetaMask}\n                />\n              ),\n            }}\n            disabled={!state.hasMetaMask}\n          />\n        )}\n      </CardContainer>\n\n      <StyledBox sx={{ flexGrow: 1 }}>\n        <Grid container spacing={4} columns={[1, 2, 3]}>\n          <Grid item xs={8} sm={4} md={2}>\n            <DividerTitle>Options</DividerTitle>\n            <Toggle\n              title=\"Use Synchronous Approval\"\n              defaultChecked={snapState.useSynchronousApprovals}\n              onToggle={handleUseSyncToggle}\n              enabled={Boolean(state.installedSnap)}\n            />\n            <Divider>&nbsp;</Divider>\n            <DividerTitle>Methods</DividerTitle>\n            <Accordion items={accountManagementMethods} />\n            <Divider />\n            <DividerTitle>Request Methods</DividerTitle>\n            <Accordion items={requestMethods} />\n            <Divider />\n          </Grid>\n          <Grid item xs={4} sm={2} md={1}>\n            <Divider />\n            <DividerTitle>Accounts</DividerTitle>\n            <AccountList\n              accounts={snapState.accounts}\n              handleDelete={async (accountIdToDelete) => {\n                await client.deleteAccount(accountIdToDelete);\n                const accounts = await client.listAccounts();\n                setSnapState({\n                  ...snapState,\n                  accounts,\n                });\n              }}\n            />\n          </Grid>\n        </Grid>\n      </StyledBox>\n    </Container>\n  );\n};\n\nexport default Index;\n"],"names":["t","Object","assign","r","e","n","arguments","length","s","prototype","hasOwnProperty","call","apply","this","Array","fill","charCodeAt","i","o","Error","match","Math","log","Uint8Array","map","indexOf","reduce","reverse","filter","h","defineProperty","value","bech32m","bech32","charAt","push","c","isArray","a","f","toLowerCase","toUpperCase","lastIndexOf","slice","u","l","prefix","words","decodeUnsafe","decode","encode","TypeError","toWords","fromWordsUnsafe","fromWords","exports","__esModule","default","constructor","A","B","C","D","E","F","G","H","_size","_sp","p","w","ArrayBuffer","_byte","_word","Int32Array","update","_utf8","byteOffset","byteLength","buffer","_int32","BYTES_PER_ELEMENT","_uint8","d","g","m","b","v","_","digest","_hex","_bin","y","toString","substr","Uint16Array","x","k","I","mainnet","testnet","regtest","p2pkh","p2sh","p2wpkh","p2wsh","p2tr","type","network","z","startsWith","bc","tb","bcrt","address","some","keys","Number","includes","StructError","failure","failures","cached","message","explanation","rest","path","cause","join","super","name","isObject","JSON","stringify","toFailure","result","context","struct","branch","refinement","key","toFailures","Symbol","iterator","isIterable","validationResult","run","options","coerce","mask","coercer","schema","undefined","status","validator","innerKey","innerValue","innerStruct","entries","iterable","Map","set","Set","add","refiner","props","assert","create","is","validate","tuples","tuple","input","done","next","shiftIterator","innerTuple","definePattern","pattern","test","UuidStruct","AccountIdStruct","UrlStruct","url","URL","protocol","StringNumberStruct","any","array","Element","index","arrayValue","enums","values","description","integer","isNaN","isInteger","literal","constant","valueType","never","nullable","ctx","number","knowns","Never","unknowns","delete","record","Key","Value","objectKey","objectValue","union","Structs","InnerStruct","error","coerced","first","hasOptional","exactOptional","strictMask","selectiveUnion","selector","condition","getSize","size","nonempty","refine","hasProperty","objectToCheck","JsonSize","field","validateJson","json","isFinite","every","UnsafeJsonStruct","JsonStruct","parse","propKey","propValue","JsonRpcVersionStruct","JsonRpcIdStruct","JsonRpcErrorStruct","code","data","stack","JsonRpcParamsStruct","id","jsonrpc","method","params","JsonRpcSuccessStruct","JsonRpcFailureStruct","proto","getPrototypeOf","KeyringAccountEntropyTypeOption","KeyringAccountEntropyMnemonicOptionsStruct","Mnemonic","derivationPath","groupIndex","KeyringAccountEntropyPrivateKeyOptionsStruct","PrivateKey","KeyringAccountEntropyOptionsStruct","KeyringAccountOptionsStruct","entropy","exportable","CAIP_CHAIN_ID_REGEX","CAIP_NAMESPACE_REGEX","CAIP_REFERENCE_REGEX","CAIP_ACCOUNT_ID_REGEX","CAIP_ACCOUNT_ADDRESS_REGEX","CAIP_ASSET_NAMESPACE_REGEX","CAIP_ASSET_REFERENCE_REGEX","CAIP_TOKEN_ID_REGEX","CAIP_ASSET_TYPE_REGEX","CAIP_ASSET_ID_REGEX","CaipChainIdStruct","CaipAccountIdStruct","CaipAssetTypeStruct","CaipAssetIdStruct","CaipAssetTypeOrIdStruct","KnownCaipNamespace","BtcAccountType","SolAccountType","TrxAccountType","AnyAccountType","EthAccountType","KeyringAccountStruct","Eoa","Erc4337","P2pkh","P2sh","P2wpkh","P2tr","DataAccount","Account","scopes","methods","FungibleAssetAmountStruct","unit","amount","FungibleAssetStruct","fungible","NonFungibleAssetStruct","AssetStruct","BalanceStruct","DerivationPathStruct","DiscoveredAccountType","DiscoveredAccountStruct","Bip44","KeyringAccountDataStruct","KeyringRequestStruct","scope","account","origin","request","KeyringResponseStruct","pending","redirect","ParticipantStruct","asset","FeeType","FeeStruct","Base","Priority","TransactionStatus","TransactionType","TransactionEventStruct","Submitted","Unconfirmed","Confirmed","Failed","timestamp","TransactionStruct","chain","Send","Receive","Swap","BridgeSend","BridgeReceive","Unknown","from","to","fees","events","TransactionsPageStruct","PaginationStruct","limit","MetaMaskOptionsStruct","metamask","correlationId","BtcScope","validateAddress","BtcP2pkhAddressStruct","BtcP2shAddressStruct","BtcP2wpkhAddressStruct","BtcP2trAddressStruct","BtcMethod","BtcAccountStruct","SolScope","SolAddressStruct","SolMethod","EthScope","EthBytesStruct","EthAddressStruct","EthUint256Struct","EthMethod","PersonalSign","Sign","SignTransaction","SignTypedDataV1","SignTypedDataV3","SignTypedDataV4","PrepareUserOperation","PatchUserOperation","SignUserOperation","sender","nonce","initCode","callData","callGasLimit","verificationGasLimit","preVerificationGas","maxFeePerGas","maxPriorityFeePerGas","paymasterAndData","signature","gasLimits","dummyPaymasterAndData","dummySignature","bundlerUrl","TrxScope","TrxAddressStruct","TrxMethod","KeyringRpcMethod","CommonHeader","ListAccountsResponseStruct","GetAccountResponseStruct","CreateAccountResponseStruct","DiscoverAccountsResponseStruct","entropySource","ListAccountTransactionsResponseStruct","pagination","ListAccountAssetsResponseStruct","GetAccountBalancesResponseStruct","GetAccountBalances","assets","ResolveAccountAddressResponseStruct","FilterAccountChainsResponseStruct","chains","UpdateAccountResponseStruct","DeleteAccountResponseStruct","ExportAccountResponseStruct","ListRequestsResponseStruct","GetRequestResponseStruct","SubmitRequestResponseStruct","ApproveRequestResponseStruct","RejectRequestResponseStruct","KeyringEvent","AccountCreated","accountNameSuggestion","displayConfirmation","displayAccountNameSuggestion","AccountUpdated","AccountDeleted","RequestApproved","RequestRejected","AccountBalancesUpdated","balances","AccountTransactionsUpdated","transactions","AccountAssetListUpdated","added","removed","randomUUID","crypto","bind","getRandomValues","rnds8","rng","byteToHex","unsafeStringify","arr","offset","_KeyringClient_sender","buf","rnds","random","__classPrivateFieldSet","receiver","state","kind","has","__classPrivateFieldGet","get","KeyringClient","send","partial","listAccounts","ListAccounts","getAccount","GetAccount","getAccountBalances","createAccount","CreateAccount","discoverAccounts","DiscoverAccounts","listAccountTransactions","ListAccountTransactions","listAccountAssets","ListAccountAssets","resolveAccountAddress","ResolveAccountAddress","filterAccountChains","FilterAccountChains","updateAccount","UpdateAccount","deleteAccount","DeleteAccount","exportAccount","ExportAccount","listRequests","ListRequests","getRequest","GetRequest","submitRequest","SubmitRequest","approveRequest","ApproveRequest","rejectRequest","RejectRequest","WeakMap","_KeyringPublicClient_client","KeyringPublicClient","_SnapRpcSender_origin","_SnapRpcSender_provider","SnapRpcSender","provider","snapId","KeyringSnapRpcClient","defaultSnapOrigin","initialState","pendingRequests","accounts","useSynchronousApprovals","Index","dispatch","useContext","MetaMaskContext","snapState","setSnapState","useState","privateKey","setPrivateKey","accountId","setAccountId","accountObject","setAccountObject","requestId","setRequestId","client","window","ethereum","useEffect","async","installedSnap","isSynchronous","isSynchronousMode","getState","catch","console","syncAccounts","handleUseSyncToggle","useCallback","toggleSynchronousApprovals","accountManagementMethods","inputs","action","callback","newAccount","label","successMessage","title","InputType","TextField","placeholder","onChange","event","currentTarget","importAccount","disabled","Boolean","TextArea","requestMethods","enabled","requests","_jsxs","Container","children","_jsx","CardContainer","Card","content","button","ConnectButton","onClick","connectSnap","getSnap","MetamaskActions","SetInstalled","payload","SetError","hasMetaMask","StyledBox","sx","flexGrow","Grid","container","spacing","columns","item","xs","sm","md","DividerTitle","Toggle","defaultChecked","onToggle","Divider","Accordion","items","AccountList","handleDelete","accountIdToDelete"],"sourceRoot":""}